{"ast":null,"code":"import _objectSpread from \"/Users/victor/Documents/Sublime/claude_api_project/chat-pwa/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _awaitAsyncGenerator from \"/Users/victor/Documents/Sublime/claude_api_project/chat-pwa/node_modules/@babel/runtime/helpers/esm/awaitAsyncGenerator.js\";\nimport _wrapAsyncGenerator from \"/Users/victor/Documents/Sublime/claude_api_project/chat-pwa/node_modules/@babel/runtime/helpers/esm/wrapAsyncGenerator.js\";\nconst instanceOfAny = (object, constructors) => constructors.some(c => object instanceof c);\nlet idbProxyableTypes;\nlet cursorAdvanceMethods;\n// This is a function to prevent it throwing up in node environments.\nfunction getIdbProxyableTypes() {\n  return idbProxyableTypes || (idbProxyableTypes = [IDBDatabase, IDBObjectStore, IDBIndex, IDBCursor, IDBTransaction]);\n}\n// This is a function to prevent it throwing up in node environments.\nfunction getCursorAdvanceMethods() {\n  return cursorAdvanceMethods || (cursorAdvanceMethods = [IDBCursor.prototype.advance, IDBCursor.prototype.continue, IDBCursor.prototype.continuePrimaryKey]);\n}\nconst transactionDoneMap = new WeakMap();\nconst transformCache = new WeakMap();\nconst reverseTransformCache = new WeakMap();\nfunction promisifyRequest(request) {\n  const promise = new Promise((resolve, reject) => {\n    const unlisten = () => {\n      request.removeEventListener('success', success);\n      request.removeEventListener('error', error);\n    };\n    const success = () => {\n      resolve(wrap(request.result));\n      unlisten();\n    };\n    const error = () => {\n      reject(request.error);\n      unlisten();\n    };\n    request.addEventListener('success', success);\n    request.addEventListener('error', error);\n  });\n  // This mapping exists in reverseTransformCache but doesn't exist in transformCache. This\n  // is because we create many promises from a single IDBRequest.\n  reverseTransformCache.set(promise, request);\n  return promise;\n}\nfunction cacheDonePromiseForTransaction(tx) {\n  // Early bail if we've already created a done promise for this transaction.\n  if (transactionDoneMap.has(tx)) return;\n  const done = new Promise((resolve, reject) => {\n    const unlisten = () => {\n      tx.removeEventListener('complete', complete);\n      tx.removeEventListener('error', error);\n      tx.removeEventListener('abort', error);\n    };\n    const complete = () => {\n      resolve();\n      unlisten();\n    };\n    const error = () => {\n      reject(tx.error || new DOMException('AbortError', 'AbortError'));\n      unlisten();\n    };\n    tx.addEventListener('complete', complete);\n    tx.addEventListener('error', error);\n    tx.addEventListener('abort', error);\n  });\n  // Cache it for later retrieval.\n  transactionDoneMap.set(tx, done);\n}\nlet idbProxyTraps = {\n  get(target, prop, receiver) {\n    if (target instanceof IDBTransaction) {\n      // Special handling for transaction.done.\n      if (prop === 'done') return transactionDoneMap.get(target);\n      // Make tx.store return the only store in the transaction, or undefined if there are many.\n      if (prop === 'store') {\n        return receiver.objectStoreNames[1] ? undefined : receiver.objectStore(receiver.objectStoreNames[0]);\n      }\n    }\n    // Else transform whatever we get back.\n    return wrap(target[prop]);\n  },\n  set(target, prop, value) {\n    target[prop] = value;\n    return true;\n  },\n  has(target, prop) {\n    if (target instanceof IDBTransaction && (prop === 'done' || prop === 'store')) {\n      return true;\n    }\n    return prop in target;\n  }\n};\nfunction replaceTraps(callback) {\n  idbProxyTraps = callback(idbProxyTraps);\n}\nfunction wrapFunction(func) {\n  // Due to expected object equality (which is enforced by the caching in `wrap`), we\n  // only create one new func per func.\n  // Cursor methods are special, as the behaviour is a little more different to standard IDB. In\n  // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the\n  // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense\n  // with real promises, so each advance methods returns a new promise for the cursor object, or\n  // undefined if the end of the cursor has been reached.\n  if (getCursorAdvanceMethods().includes(func)) {\n    return function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n      // the original object.\n      func.apply(unwrap(this), args);\n      return wrap(this.request);\n    };\n  }\n  return function () {\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n    // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n    // the original object.\n    return wrap(func.apply(unwrap(this), args));\n  };\n}\nfunction transformCachableValue(value) {\n  if (typeof value === 'function') return wrapFunction(value);\n  // This doesn't return, it just creates a 'done' promise for the transaction,\n  // which is later returned for transaction.done (see idbObjectHandler).\n  if (value instanceof IDBTransaction) cacheDonePromiseForTransaction(value);\n  if (instanceOfAny(value, getIdbProxyableTypes())) return new Proxy(value, idbProxyTraps);\n  // Return the same value back if we're not going to transform it.\n  return value;\n}\nfunction wrap(value) {\n  // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because\n  // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.\n  if (value instanceof IDBRequest) return promisifyRequest(value);\n  // If we've already transformed this value before, reuse the transformed value.\n  // This is faster, but it also provides object equality.\n  if (transformCache.has(value)) return transformCache.get(value);\n  const newValue = transformCachableValue(value);\n  // Not all types are transformed.\n  // These may be primitive types, so they can't be WeakMap keys.\n  if (newValue !== value) {\n    transformCache.set(value, newValue);\n    reverseTransformCache.set(newValue, value);\n  }\n  return newValue;\n}\nconst unwrap = value => reverseTransformCache.get(value);\n\n/**\n * Open a database.\n *\n * @param name Name of the database.\n * @param version Schema version.\n * @param callbacks Additional callbacks.\n */\nfunction openDB(name, version) {\n  let {\n    blocked,\n    upgrade,\n    blocking,\n    terminated\n  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const request = indexedDB.open(name, version);\n  const openPromise = wrap(request);\n  if (upgrade) {\n    request.addEventListener('upgradeneeded', event => {\n      upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction), event);\n    });\n  }\n  if (blocked) {\n    request.addEventListener('blocked', event => blocked(\n    // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n    event.oldVersion, event.newVersion, event));\n  }\n  openPromise.then(db => {\n    if (terminated) db.addEventListener('close', () => terminated());\n    if (blocking) {\n      db.addEventListener('versionchange', event => blocking(event.oldVersion, event.newVersion, event));\n    }\n  }).catch(() => {});\n  return openPromise;\n}\n/**\n * Delete a database.\n *\n * @param name Name of the database.\n */\nfunction deleteDB(name) {\n  let {\n    blocked\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const request = indexedDB.deleteDatabase(name);\n  if (blocked) {\n    request.addEventListener('blocked', event => blocked(\n    // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n    event.oldVersion, event));\n  }\n  return wrap(request).then(() => undefined);\n}\nconst readMethods = ['get', 'getKey', 'getAll', 'getAllKeys', 'count'];\nconst writeMethods = ['put', 'add', 'delete', 'clear'];\nconst cachedMethods = new Map();\nfunction getMethod(target, prop) {\n  if (!(target instanceof IDBDatabase && !(prop in target) && typeof prop === 'string')) {\n    return;\n  }\n  if (cachedMethods.get(prop)) return cachedMethods.get(prop);\n  const targetFuncName = prop.replace(/FromIndex$/, '');\n  const useIndex = prop !== targetFuncName;\n  const isWrite = writeMethods.includes(targetFuncName);\n  if (\n  // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.\n  !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) || !(isWrite || readMethods.includes(targetFuncName))) {\n    return;\n  }\n  const method = async function (storeName) {\n    // isWrite ? 'readwrite' : undefined gzipps better, but fails in Edge :(\n    const tx = this.transaction(storeName, isWrite ? 'readwrite' : 'readonly');\n    let target = tx.store;\n    for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n      args[_key3 - 1] = arguments[_key3];\n    }\n    if (useIndex) target = target.index(args.shift());\n    // Must reject if op rejects.\n    // If it's a write operation, must reject if tx.done rejects.\n    // Must reject with op rejection first.\n    // Must resolve with op value.\n    // Must handle both promises (no unhandled rejections)\n    return (await Promise.all([target[targetFuncName](...args), isWrite && tx.done]))[0];\n  };\n  cachedMethods.set(prop, method);\n  return method;\n}\nreplaceTraps(oldTraps => _objectSpread(_objectSpread({}, oldTraps), {}, {\n  get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),\n  has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop)\n}));\nconst advanceMethodProps = ['continue', 'continuePrimaryKey', 'advance'];\nconst methodMap = {};\nconst advanceResults = new WeakMap();\nconst ittrProxiedCursorToOriginalProxy = new WeakMap();\nconst cursorIteratorTraps = {\n  get(target, prop) {\n    if (!advanceMethodProps.includes(prop)) return target[prop];\n    let cachedFunc = methodMap[prop];\n    if (!cachedFunc) {\n      cachedFunc = methodMap[prop] = function () {\n        advanceResults.set(this, ittrProxiedCursorToOriginalProxy.get(this)[prop](...arguments));\n      };\n    }\n    return cachedFunc;\n  }\n};\nfunction iterate() {\n  return _iterate.apply(this, arguments);\n}\nfunction _iterate() {\n  _iterate = _wrapAsyncGenerator(function* () {\n    // tslint:disable-next-line:no-this-assignment\n    let cursor = this;\n    if (!(cursor instanceof IDBCursor)) {\n      cursor = yield _awaitAsyncGenerator(cursor.openCursor(...arguments));\n    }\n    if (!cursor) return;\n    cursor = cursor;\n    const proxiedCursor = new Proxy(cursor, cursorIteratorTraps);\n    ittrProxiedCursorToOriginalProxy.set(proxiedCursor, cursor);\n    // Map this double-proxy back to the original, so other cursor methods work.\n    reverseTransformCache.set(proxiedCursor, unwrap(cursor));\n    while (cursor) {\n      yield proxiedCursor;\n      // If one of the advancing methods was not called, call continue().\n      cursor = yield _awaitAsyncGenerator(advanceResults.get(proxiedCursor) || cursor.continue());\n      advanceResults.delete(proxiedCursor);\n    }\n  });\n  return _iterate.apply(this, arguments);\n}\nfunction isIteratorProp(target, prop) {\n  return prop === Symbol.asyncIterator && instanceOfAny(target, [IDBIndex, IDBObjectStore, IDBCursor]) || prop === 'iterate' && instanceOfAny(target, [IDBIndex, IDBObjectStore]);\n}\nreplaceTraps(oldTraps => _objectSpread(_objectSpread({}, oldTraps), {}, {\n  get(target, prop, receiver) {\n    if (isIteratorProp(target, prop)) return iterate;\n    return oldTraps.get(target, prop, receiver);\n  },\n  has(target, prop) {\n    return isIteratorProp(target, prop) || oldTraps.has(target, prop);\n  }\n}));\nexport { deleteDB, openDB, unwrap, wrap };","map":{"version":3,"names":["instanceOfAny","object","constructors","some","c","idbProxyableTypes","cursorAdvanceMethods","getIdbProxyableTypes","IDBDatabase","IDBObjectStore","IDBIndex","IDBCursor","IDBTransaction","getCursorAdvanceMethods","prototype","advance","continue","continuePrimaryKey","transactionDoneMap","WeakMap","transformCache","reverseTransformCache","promisifyRequest","request","promise","Promise","resolve","reject","unlisten","removeEventListener","success","error","wrap","result","addEventListener","set","cacheDonePromiseForTransaction","tx","has","done","complete","DOMException","idbProxyTraps","get","target","prop","receiver","objectStoreNames","undefined","objectStore","value","replaceTraps","callback","wrapFunction","func","includes","_len","arguments","length","args","Array","_key","apply","unwrap","_len2","_key2","transformCachableValue","Proxy","IDBRequest","newValue","openDB","name","version","blocked","upgrade","blocking","terminated","indexedDB","open","openPromise","event","oldVersion","newVersion","transaction","then","db","catch","deleteDB","deleteDatabase","readMethods","writeMethods","cachedMethods","Map","getMethod","targetFuncName","replace","useIndex","isWrite","method","storeName","store","_len3","_key3","index","shift","all","oldTraps","_objectSpread","advanceMethodProps","methodMap","advanceResults","ittrProxiedCursorToOriginalProxy","cursorIteratorTraps","cachedFunc","iterate","_iterate","_wrapAsyncGenerator","cursor","_awaitAsyncGenerator","openCursor","proxiedCursor","delete","isIteratorProp","Symbol","asyncIterator"],"sources":["/Users/victor/Documents/Sublime/claude_api_project/chat-pwa/node_modules/idb/build/index.js"],"sourcesContent":["const instanceOfAny = (object, constructors) => constructors.some((c) => object instanceof c);\n\nlet idbProxyableTypes;\nlet cursorAdvanceMethods;\n// This is a function to prevent it throwing up in node environments.\nfunction getIdbProxyableTypes() {\n    return (idbProxyableTypes ||\n        (idbProxyableTypes = [\n            IDBDatabase,\n            IDBObjectStore,\n            IDBIndex,\n            IDBCursor,\n            IDBTransaction,\n        ]));\n}\n// This is a function to prevent it throwing up in node environments.\nfunction getCursorAdvanceMethods() {\n    return (cursorAdvanceMethods ||\n        (cursorAdvanceMethods = [\n            IDBCursor.prototype.advance,\n            IDBCursor.prototype.continue,\n            IDBCursor.prototype.continuePrimaryKey,\n        ]));\n}\nconst transactionDoneMap = new WeakMap();\nconst transformCache = new WeakMap();\nconst reverseTransformCache = new WeakMap();\nfunction promisifyRequest(request) {\n    const promise = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            request.removeEventListener('success', success);\n            request.removeEventListener('error', error);\n        };\n        const success = () => {\n            resolve(wrap(request.result));\n            unlisten();\n        };\n        const error = () => {\n            reject(request.error);\n            unlisten();\n        };\n        request.addEventListener('success', success);\n        request.addEventListener('error', error);\n    });\n    // This mapping exists in reverseTransformCache but doesn't exist in transformCache. This\n    // is because we create many promises from a single IDBRequest.\n    reverseTransformCache.set(promise, request);\n    return promise;\n}\nfunction cacheDonePromiseForTransaction(tx) {\n    // Early bail if we've already created a done promise for this transaction.\n    if (transactionDoneMap.has(tx))\n        return;\n    const done = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            tx.removeEventListener('complete', complete);\n            tx.removeEventListener('error', error);\n            tx.removeEventListener('abort', error);\n        };\n        const complete = () => {\n            resolve();\n            unlisten();\n        };\n        const error = () => {\n            reject(tx.error || new DOMException('AbortError', 'AbortError'));\n            unlisten();\n        };\n        tx.addEventListener('complete', complete);\n        tx.addEventListener('error', error);\n        tx.addEventListener('abort', error);\n    });\n    // Cache it for later retrieval.\n    transactionDoneMap.set(tx, done);\n}\nlet idbProxyTraps = {\n    get(target, prop, receiver) {\n        if (target instanceof IDBTransaction) {\n            // Special handling for transaction.done.\n            if (prop === 'done')\n                return transactionDoneMap.get(target);\n            // Make tx.store return the only store in the transaction, or undefined if there are many.\n            if (prop === 'store') {\n                return receiver.objectStoreNames[1]\n                    ? undefined\n                    : receiver.objectStore(receiver.objectStoreNames[0]);\n            }\n        }\n        // Else transform whatever we get back.\n        return wrap(target[prop]);\n    },\n    set(target, prop, value) {\n        target[prop] = value;\n        return true;\n    },\n    has(target, prop) {\n        if (target instanceof IDBTransaction &&\n            (prop === 'done' || prop === 'store')) {\n            return true;\n        }\n        return prop in target;\n    },\n};\nfunction replaceTraps(callback) {\n    idbProxyTraps = callback(idbProxyTraps);\n}\nfunction wrapFunction(func) {\n    // Due to expected object equality (which is enforced by the caching in `wrap`), we\n    // only create one new func per func.\n    // Cursor methods are special, as the behaviour is a little more different to standard IDB. In\n    // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the\n    // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense\n    // with real promises, so each advance methods returns a new promise for the cursor object, or\n    // undefined if the end of the cursor has been reached.\n    if (getCursorAdvanceMethods().includes(func)) {\n        return function (...args) {\n            // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n            // the original object.\n            func.apply(unwrap(this), args);\n            return wrap(this.request);\n        };\n    }\n    return function (...args) {\n        // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n        // the original object.\n        return wrap(func.apply(unwrap(this), args));\n    };\n}\nfunction transformCachableValue(value) {\n    if (typeof value === 'function')\n        return wrapFunction(value);\n    // This doesn't return, it just creates a 'done' promise for the transaction,\n    // which is later returned for transaction.done (see idbObjectHandler).\n    if (value instanceof IDBTransaction)\n        cacheDonePromiseForTransaction(value);\n    if (instanceOfAny(value, getIdbProxyableTypes()))\n        return new Proxy(value, idbProxyTraps);\n    // Return the same value back if we're not going to transform it.\n    return value;\n}\nfunction wrap(value) {\n    // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because\n    // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.\n    if (value instanceof IDBRequest)\n        return promisifyRequest(value);\n    // If we've already transformed this value before, reuse the transformed value.\n    // This is faster, but it also provides object equality.\n    if (transformCache.has(value))\n        return transformCache.get(value);\n    const newValue = transformCachableValue(value);\n    // Not all types are transformed.\n    // These may be primitive types, so they can't be WeakMap keys.\n    if (newValue !== value) {\n        transformCache.set(value, newValue);\n        reverseTransformCache.set(newValue, value);\n    }\n    return newValue;\n}\nconst unwrap = (value) => reverseTransformCache.get(value);\n\n/**\n * Open a database.\n *\n * @param name Name of the database.\n * @param version Schema version.\n * @param callbacks Additional callbacks.\n */\nfunction openDB(name, version, { blocked, upgrade, blocking, terminated } = {}) {\n    const request = indexedDB.open(name, version);\n    const openPromise = wrap(request);\n    if (upgrade) {\n        request.addEventListener('upgradeneeded', (event) => {\n            upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction), event);\n        });\n    }\n    if (blocked) {\n        request.addEventListener('blocked', (event) => blocked(\n        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n        event.oldVersion, event.newVersion, event));\n    }\n    openPromise\n        .then((db) => {\n        if (terminated)\n            db.addEventListener('close', () => terminated());\n        if (blocking) {\n            db.addEventListener('versionchange', (event) => blocking(event.oldVersion, event.newVersion, event));\n        }\n    })\n        .catch(() => { });\n    return openPromise;\n}\n/**\n * Delete a database.\n *\n * @param name Name of the database.\n */\nfunction deleteDB(name, { blocked } = {}) {\n    const request = indexedDB.deleteDatabase(name);\n    if (blocked) {\n        request.addEventListener('blocked', (event) => blocked(\n        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n        event.oldVersion, event));\n    }\n    return wrap(request).then(() => undefined);\n}\n\nconst readMethods = ['get', 'getKey', 'getAll', 'getAllKeys', 'count'];\nconst writeMethods = ['put', 'add', 'delete', 'clear'];\nconst cachedMethods = new Map();\nfunction getMethod(target, prop) {\n    if (!(target instanceof IDBDatabase &&\n        !(prop in target) &&\n        typeof prop === 'string')) {\n        return;\n    }\n    if (cachedMethods.get(prop))\n        return cachedMethods.get(prop);\n    const targetFuncName = prop.replace(/FromIndex$/, '');\n    const useIndex = prop !== targetFuncName;\n    const isWrite = writeMethods.includes(targetFuncName);\n    if (\n    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.\n    !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) ||\n        !(isWrite || readMethods.includes(targetFuncName))) {\n        return;\n    }\n    const method = async function (storeName, ...args) {\n        // isWrite ? 'readwrite' : undefined gzipps better, but fails in Edge :(\n        const tx = this.transaction(storeName, isWrite ? 'readwrite' : 'readonly');\n        let target = tx.store;\n        if (useIndex)\n            target = target.index(args.shift());\n        // Must reject if op rejects.\n        // If it's a write operation, must reject if tx.done rejects.\n        // Must reject with op rejection first.\n        // Must resolve with op value.\n        // Must handle both promises (no unhandled rejections)\n        return (await Promise.all([\n            target[targetFuncName](...args),\n            isWrite && tx.done,\n        ]))[0];\n    };\n    cachedMethods.set(prop, method);\n    return method;\n}\nreplaceTraps((oldTraps) => ({\n    ...oldTraps,\n    get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),\n    has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop),\n}));\n\nconst advanceMethodProps = ['continue', 'continuePrimaryKey', 'advance'];\nconst methodMap = {};\nconst advanceResults = new WeakMap();\nconst ittrProxiedCursorToOriginalProxy = new WeakMap();\nconst cursorIteratorTraps = {\n    get(target, prop) {\n        if (!advanceMethodProps.includes(prop))\n            return target[prop];\n        let cachedFunc = methodMap[prop];\n        if (!cachedFunc) {\n            cachedFunc = methodMap[prop] = function (...args) {\n                advanceResults.set(this, ittrProxiedCursorToOriginalProxy.get(this)[prop](...args));\n            };\n        }\n        return cachedFunc;\n    },\n};\nasync function* iterate(...args) {\n    // tslint:disable-next-line:no-this-assignment\n    let cursor = this;\n    if (!(cursor instanceof IDBCursor)) {\n        cursor = await cursor.openCursor(...args);\n    }\n    if (!cursor)\n        return;\n    cursor = cursor;\n    const proxiedCursor = new Proxy(cursor, cursorIteratorTraps);\n    ittrProxiedCursorToOriginalProxy.set(proxiedCursor, cursor);\n    // Map this double-proxy back to the original, so other cursor methods work.\n    reverseTransformCache.set(proxiedCursor, unwrap(cursor));\n    while (cursor) {\n        yield proxiedCursor;\n        // If one of the advancing methods was not called, call continue().\n        cursor = await (advanceResults.get(proxiedCursor) || cursor.continue());\n        advanceResults.delete(proxiedCursor);\n    }\n}\nfunction isIteratorProp(target, prop) {\n    return ((prop === Symbol.asyncIterator &&\n        instanceOfAny(target, [IDBIndex, IDBObjectStore, IDBCursor])) ||\n        (prop === 'iterate' && instanceOfAny(target, [IDBIndex, IDBObjectStore])));\n}\nreplaceTraps((oldTraps) => ({\n    ...oldTraps,\n    get(target, prop, receiver) {\n        if (isIteratorProp(target, prop))\n            return iterate;\n        return oldTraps.get(target, prop, receiver);\n    },\n    has(target, prop) {\n        return isIteratorProp(target, prop) || oldTraps.has(target, prop);\n    },\n}));\n\nexport { deleteDB, openDB, unwrap, wrap };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}