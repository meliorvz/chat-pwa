{"ast":null,"code":"import _objectSpread from \"/Users/victor/Documents/Sublime/claude_api_project/chat-pwa/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _asyncIterator from \"/Users/victor/Documents/Sublime/claude_api_project/chat-pwa/node_modules/@babel/runtime/helpers/esm/asyncIterator.js\";\nvar __classPrivateFieldSet = this && this.__classPrivateFieldSet || function (receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n};\nvar __classPrivateFieldGet = this && this.__classPrivateFieldGet || function (receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _MessageStream_instances, _MessageStream_currentMessageSnapshot, _MessageStream_connectedPromise, _MessageStream_resolveConnectedPromise, _MessageStream_rejectConnectedPromise, _MessageStream_endPromise, _MessageStream_resolveEndPromise, _MessageStream_rejectEndPromise, _MessageStream_listeners, _MessageStream_ended, _MessageStream_errored, _MessageStream_aborted, _MessageStream_catchingPromiseCreated, _MessageStream_getFinalMessage, _MessageStream_getFinalText, _MessageStream_handleError, _MessageStream_beginRequest, _MessageStream_addStreamEvent, _MessageStream_endRequest, _MessageStream_accumulateMessage;\nimport { AnthropicError, APIUserAbortError } from '@anthropic-ai/sdk/error';\nimport { Stream } from '@anthropic-ai/sdk/streaming';\nexport class MessageStream {\n  constructor() {\n    _MessageStream_instances.add(this);\n    this.messages = [];\n    this.receivedMessages = [];\n    _MessageStream_currentMessageSnapshot.set(this, void 0);\n    this.controller = new AbortController();\n    _MessageStream_connectedPromise.set(this, void 0);\n    _MessageStream_resolveConnectedPromise.set(this, () => {});\n    _MessageStream_rejectConnectedPromise.set(this, () => {});\n    _MessageStream_endPromise.set(this, void 0);\n    _MessageStream_resolveEndPromise.set(this, () => {});\n    _MessageStream_rejectEndPromise.set(this, () => {});\n    _MessageStream_listeners.set(this, {});\n    _MessageStream_ended.set(this, false);\n    _MessageStream_errored.set(this, false);\n    _MessageStream_aborted.set(this, false);\n    _MessageStream_catchingPromiseCreated.set(this, false);\n    _MessageStream_handleError.set(this, error => {\n      __classPrivateFieldSet(this, _MessageStream_errored, true, \"f\");\n      if (error instanceof Error && error.name === 'AbortError') {\n        error = new APIUserAbortError();\n      }\n      if (error instanceof APIUserAbortError) {\n        __classPrivateFieldSet(this, _MessageStream_aborted, true, \"f\");\n        return this._emit('abort', error);\n      }\n      if (error instanceof AnthropicError) {\n        return this._emit('error', error);\n      }\n      if (error instanceof Error) {\n        const anthropicError = new AnthropicError(error.message);\n        // @ts-ignore\n        anthropicError.cause = error;\n        return this._emit('error', anthropicError);\n      }\n      return this._emit('error', new AnthropicError(String(error)));\n    });\n    __classPrivateFieldSet(this, _MessageStream_connectedPromise, new Promise((resolve, reject) => {\n      __classPrivateFieldSet(this, _MessageStream_resolveConnectedPromise, resolve, \"f\");\n      __classPrivateFieldSet(this, _MessageStream_rejectConnectedPromise, reject, \"f\");\n    }), \"f\");\n    __classPrivateFieldSet(this, _MessageStream_endPromise, new Promise((resolve, reject) => {\n      __classPrivateFieldSet(this, _MessageStream_resolveEndPromise, resolve, \"f\");\n      __classPrivateFieldSet(this, _MessageStream_rejectEndPromise, reject, \"f\");\n    }), \"f\");\n    // Don't let these promises cause unhandled rejection errors.\n    // we will manually cause an unhandled rejection error later\n    // if the user hasn't registered any error listener or called\n    // any promise-returning method.\n    __classPrivateFieldGet(this, _MessageStream_connectedPromise, \"f\").catch(() => {});\n    __classPrivateFieldGet(this, _MessageStream_endPromise, \"f\").catch(() => {});\n  }\n  /**\n   * Intended for use on the frontend, consuming a stream produced with\n   * `.toReadableStream()` on the backend.\n   *\n   * Note that messages sent to the model do not appear in `.on('message')`\n   * in this context.\n   */\n  static fromReadableStream(stream) {\n    const runner = new MessageStream();\n    runner._run(() => runner._fromReadableStream(stream));\n    return runner;\n  }\n  static createMessage(messages, params, options) {\n    const runner = new MessageStream();\n    for (const message of params.messages) {\n      runner._addMessageParam(message);\n    }\n    runner._run(() => runner._createMessage(messages, _objectSpread(_objectSpread({}, params), {}, {\n      stream: true\n    }), _objectSpread(_objectSpread({}, options), {}, {\n      headers: _objectSpread(_objectSpread({}, options === null || options === void 0 ? void 0 : options.headers), {}, {\n        'X-Stainless-Helper-Method': 'stream'\n      })\n    })));\n    return runner;\n  }\n  _run(executor) {\n    executor().then(() => {\n      this._emitFinal();\n      this._emit('end');\n    }, __classPrivateFieldGet(this, _MessageStream_handleError, \"f\"));\n  }\n  _addMessageParam(message) {\n    this.messages.push(message);\n  }\n  _addMessage(message) {\n    let emit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    this.receivedMessages.push(message);\n    if (emit) {\n      this._emit('message', message);\n    }\n  }\n  async _createMessage(messages, params, options) {\n    var _stream$controller$si;\n    const signal = options === null || options === void 0 ? void 0 : options.signal;\n    if (signal) {\n      if (signal.aborted) this.controller.abort();\n      signal.addEventListener('abort', () => this.controller.abort());\n    }\n    __classPrivateFieldGet(this, _MessageStream_instances, \"m\", _MessageStream_beginRequest).call(this);\n    const stream = await messages.create(_objectSpread(_objectSpread({}, params), {}, {\n      stream: true\n    }), _objectSpread(_objectSpread({}, options), {}, {\n      signal: this.controller.signal\n    }));\n    this._connected();\n    var _iteratorAbruptCompletion = false;\n    var _didIteratorError = false;\n    var _iteratorError;\n    try {\n      for (var _iterator = _asyncIterator(stream), _step; _iteratorAbruptCompletion = !(_step = await _iterator.next()).done; _iteratorAbruptCompletion = false) {\n        const event = _step.value;\n        {\n          __classPrivateFieldGet(this, _MessageStream_instances, \"m\", _MessageStream_addStreamEvent).call(this, event);\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (_iteratorAbruptCompletion && _iterator.return != null) {\n          await _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n    if ((_stream$controller$si = stream.controller.signal) !== null && _stream$controller$si !== void 0 && _stream$controller$si.aborted) {\n      throw new APIUserAbortError();\n    }\n    __classPrivateFieldGet(this, _MessageStream_instances, \"m\", _MessageStream_endRequest).call(this);\n  }\n  _connected() {\n    if (this.ended) return;\n    __classPrivateFieldGet(this, _MessageStream_resolveConnectedPromise, \"f\").call(this);\n    this._emit('connect');\n  }\n  get ended() {\n    return __classPrivateFieldGet(this, _MessageStream_ended, \"f\");\n  }\n  get errored() {\n    return __classPrivateFieldGet(this, _MessageStream_errored, \"f\");\n  }\n  get aborted() {\n    return __classPrivateFieldGet(this, _MessageStream_aborted, \"f\");\n  }\n  abort() {\n    this.controller.abort();\n  }\n  /**\n   * Adds the listener function to the end of the listeners array for the event.\n   * No checks are made to see if the listener has already been added. Multiple calls passing\n   * the same combination of event and listener will result in the listener being added, and\n   * called, multiple times.\n   * @returns this MessageStream, so that calls can be chained\n   */\n  on(event, listener) {\n    const listeners = __classPrivateFieldGet(this, _MessageStream_listeners, \"f\")[event] || (__classPrivateFieldGet(this, _MessageStream_listeners, \"f\")[event] = []);\n    listeners.push({\n      listener\n    });\n    return this;\n  }\n  /**\n   * Removes the specified listener from the listener array for the event.\n   * off() will remove, at most, one instance of a listener from the listener array. If any single\n   * listener has been added multiple times to the listener array for the specified event, then\n   * off() must be called multiple times to remove each instance.\n   * @returns this MessageStream, so that calls can be chained\n   */\n  off(event, listener) {\n    const listeners = __classPrivateFieldGet(this, _MessageStream_listeners, \"f\")[event];\n    if (!listeners) return this;\n    const index = listeners.findIndex(l => l.listener === listener);\n    if (index >= 0) listeners.splice(index, 1);\n    return this;\n  }\n  /**\n   * Adds a one-time listener function for the event. The next time the event is triggered,\n   * this listener is removed and then invoked.\n   * @returns this MessageStream, so that calls can be chained\n   */\n  once(event, listener) {\n    const listeners = __classPrivateFieldGet(this, _MessageStream_listeners, \"f\")[event] || (__classPrivateFieldGet(this, _MessageStream_listeners, \"f\")[event] = []);\n    listeners.push({\n      listener,\n      once: true\n    });\n    return this;\n  }\n  /**\n   * This is similar to `.once()`, but returns a Promise that resolves the next time\n   * the event is triggered, instead of calling a listener callback.\n   * @returns a Promise that resolves the next time given event is triggered,\n   * or rejects if an error is emitted.  (If you request the 'error' event,\n   * returns a promise that resolves with the error).\n   *\n   * Example:\n   *\n   *   const message = await stream.emitted('message') // rejects if the stream errors\n   */\n  emitted(event) {\n    return new Promise((resolve, reject) => {\n      __classPrivateFieldSet(this, _MessageStream_catchingPromiseCreated, true, \"f\");\n      if (event !== 'error') this.once('error', reject);\n      this.once(event, resolve);\n    });\n  }\n  async done() {\n    __classPrivateFieldSet(this, _MessageStream_catchingPromiseCreated, true, \"f\");\n    await __classPrivateFieldGet(this, _MessageStream_endPromise, \"f\");\n  }\n  get currentMessage() {\n    return __classPrivateFieldGet(this, _MessageStream_currentMessageSnapshot, \"f\");\n  }\n  /**\n   * @returns a promise that resolves with the the final assistant Message response,\n   * or rejects if an error occurred or the stream ended prematurely without producing a Message.\n   */\n  async finalMessage() {\n    await this.done();\n    return __classPrivateFieldGet(this, _MessageStream_instances, \"m\", _MessageStream_getFinalMessage).call(this);\n  }\n  /**\n   * @returns a promise that resolves with the the final assistant Message's text response, concatenated\n   * together if there are more than one text blocks.\n   * Rejects if an error occurred or the stream ended prematurely without producing a Message.\n   */\n  async finalText() {\n    await this.done();\n    return __classPrivateFieldGet(this, _MessageStream_instances, \"m\", _MessageStream_getFinalText).call(this);\n  }\n  _emit(event) {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n    // make sure we don't emit any MessageStreamEvents after end\n    if (__classPrivateFieldGet(this, _MessageStream_ended, \"f\")) return;\n    if (event === 'end') {\n      __classPrivateFieldSet(this, _MessageStream_ended, true, \"f\");\n      __classPrivateFieldGet(this, _MessageStream_resolveEndPromise, \"f\").call(this);\n    }\n    const listeners = __classPrivateFieldGet(this, _MessageStream_listeners, \"f\")[event];\n    if (listeners) {\n      __classPrivateFieldGet(this, _MessageStream_listeners, \"f\")[event] = listeners.filter(l => !l.once);\n      listeners.forEach(_ref => {\n        let {\n          listener\n        } = _ref;\n        return listener(...args);\n      });\n    }\n    if (event === 'abort') {\n      const error = args[0];\n      if (!__classPrivateFieldGet(this, _MessageStream_catchingPromiseCreated, \"f\") && !(listeners !== null && listeners !== void 0 && listeners.length)) {\n        Promise.reject(error);\n      }\n      __classPrivateFieldGet(this, _MessageStream_rejectConnectedPromise, \"f\").call(this, error);\n      __classPrivateFieldGet(this, _MessageStream_rejectEndPromise, \"f\").call(this, error);\n      this._emit('end');\n      return;\n    }\n    if (event === 'error') {\n      // NOTE: _emit('error', error) should only be called from #handleError().\n      const error = args[0];\n      if (!__classPrivateFieldGet(this, _MessageStream_catchingPromiseCreated, \"f\") && !(listeners !== null && listeners !== void 0 && listeners.length)) {\n        // Trigger an unhandled rejection if the user hasn't registered any error handlers.\n        // If you are seeing stack traces here, make sure to handle errors via either:\n        // - runner.on('error', () => ...)\n        // - await runner.done()\n        // - await runner.final...()\n        // - etc.\n        Promise.reject(error);\n      }\n      __classPrivateFieldGet(this, _MessageStream_rejectConnectedPromise, \"f\").call(this, error);\n      __classPrivateFieldGet(this, _MessageStream_rejectEndPromise, \"f\").call(this, error);\n      this._emit('end');\n    }\n  }\n  _emitFinal() {\n    const finalMessage = this.receivedMessages.at(-1);\n    if (finalMessage) {\n      this._emit('finalMessage', __classPrivateFieldGet(this, _MessageStream_instances, \"m\", _MessageStream_getFinalMessage).call(this));\n    }\n  }\n  async _fromReadableStream(readableStream, options) {\n    var _stream$controller$si2;\n    const signal = options === null || options === void 0 ? void 0 : options.signal;\n    if (signal) {\n      if (signal.aborted) this.controller.abort();\n      signal.addEventListener('abort', () => this.controller.abort());\n    }\n    __classPrivateFieldGet(this, _MessageStream_instances, \"m\", _MessageStream_beginRequest).call(this);\n    this._connected();\n    const stream = Stream.fromReadableStream(readableStream, this.controller);\n    var _iteratorAbruptCompletion2 = false;\n    var _didIteratorError2 = false;\n    var _iteratorError2;\n    try {\n      for (var _iterator2 = _asyncIterator(stream), _step2; _iteratorAbruptCompletion2 = !(_step2 = await _iterator2.next()).done; _iteratorAbruptCompletion2 = false) {\n        const event = _step2.value;\n        {\n          __classPrivateFieldGet(this, _MessageStream_instances, \"m\", _MessageStream_addStreamEvent).call(this, event);\n        }\n      }\n    } catch (err) {\n      _didIteratorError2 = true;\n      _iteratorError2 = err;\n    } finally {\n      try {\n        if (_iteratorAbruptCompletion2 && _iterator2.return != null) {\n          await _iterator2.return();\n        }\n      } finally {\n        if (_didIteratorError2) {\n          throw _iteratorError2;\n        }\n      }\n    }\n    if ((_stream$controller$si2 = stream.controller.signal) !== null && _stream$controller$si2 !== void 0 && _stream$controller$si2.aborted) {\n      throw new APIUserAbortError();\n    }\n    __classPrivateFieldGet(this, _MessageStream_instances, \"m\", _MessageStream_endRequest).call(this);\n  }\n  [(_MessageStream_currentMessageSnapshot = new WeakMap(), _MessageStream_connectedPromise = new WeakMap(), _MessageStream_resolveConnectedPromise = new WeakMap(), _MessageStream_rejectConnectedPromise = new WeakMap(), _MessageStream_endPromise = new WeakMap(), _MessageStream_resolveEndPromise = new WeakMap(), _MessageStream_rejectEndPromise = new WeakMap(), _MessageStream_listeners = new WeakMap(), _MessageStream_ended = new WeakMap(), _MessageStream_errored = new WeakMap(), _MessageStream_aborted = new WeakMap(), _MessageStream_catchingPromiseCreated = new WeakMap(), _MessageStream_handleError = new WeakMap(), _MessageStream_instances = new WeakSet(), _MessageStream_getFinalMessage = function _MessageStream_getFinalMessage() {\n    if (this.receivedMessages.length === 0) {\n      throw new AnthropicError('stream ended without producing a Message with role=assistant');\n    }\n    return this.receivedMessages.at(-1);\n  }, _MessageStream_getFinalText = function _MessageStream_getFinalText() {\n    if (this.receivedMessages.length === 0) {\n      throw new AnthropicError('stream ended without producing a Message with role=assistant');\n    }\n    const textBlocks = this.receivedMessages.at(-1).content.filter(block => block.type === 'text').map(block => block.text);\n    if (textBlocks.length === 0) {\n      throw new AnthropicError('stream ended without producing a content block with type=text');\n    }\n    return textBlocks.join(' ');\n  }, _MessageStream_beginRequest = function _MessageStream_beginRequest() {\n    if (this.ended) return;\n    __classPrivateFieldSet(this, _MessageStream_currentMessageSnapshot, undefined, \"f\");\n  }, _MessageStream_addStreamEvent = function _MessageStream_addStreamEvent(event) {\n    if (this.ended) return;\n    const messageSnapshot = __classPrivateFieldGet(this, _MessageStream_instances, \"m\", _MessageStream_accumulateMessage).call(this, event);\n    this._emit('streamEvent', event, messageSnapshot);\n    switch (event.type) {\n      case 'content_block_delta':\n        {\n          if (event.delta.type === 'text_delta') {\n            this._emit('text', event.delta.text, messageSnapshot.content.at(-1).text || '');\n          }\n          break;\n        }\n      case 'message_stop':\n        {\n          this._addMessageParam(messageSnapshot);\n          this._addMessage(messageSnapshot, true);\n          break;\n        }\n      case 'content_block_stop':\n        {\n          this._emit('contentBlock', messageSnapshot.content.at(-1));\n          break;\n        }\n      case 'message_start':\n        {\n          __classPrivateFieldSet(this, _MessageStream_currentMessageSnapshot, messageSnapshot, \"f\");\n          break;\n        }\n      case 'content_block_start':\n      case 'message_delta':\n        break;\n    }\n  }, _MessageStream_endRequest = function _MessageStream_endRequest() {\n    if (this.ended) {\n      throw new AnthropicError(\"stream has ended, this shouldn't happen\");\n    }\n    const snapshot = __classPrivateFieldGet(this, _MessageStream_currentMessageSnapshot, \"f\");\n    if (!snapshot) {\n      throw new AnthropicError(\"request ended without sending any chunks\");\n    }\n    __classPrivateFieldSet(this, _MessageStream_currentMessageSnapshot, undefined, \"f\");\n    return snapshot;\n  }, _MessageStream_accumulateMessage = function _MessageStream_accumulateMessage(event) {\n    let snapshot = __classPrivateFieldGet(this, _MessageStream_currentMessageSnapshot, \"f\");\n    if (event.type === 'message_start') {\n      if (snapshot) {\n        throw new AnthropicError(\"Unexpected event order, got \".concat(event.type, \" before receiving \\\"message_stop\\\"\"));\n      }\n      return event.message;\n    }\n    if (!snapshot) {\n      throw new AnthropicError(\"Unexpected event order, got \".concat(event.type, \" before \\\"message_start\\\"\"));\n    }\n    switch (event.type) {\n      case 'message_stop':\n        return snapshot;\n      case 'message_delta':\n        snapshot.stop_reason = event.delta.stop_reason;\n        snapshot.stop_sequence = event.delta.stop_sequence;\n        return snapshot;\n      case 'content_block_start':\n        snapshot.content.push(event.content_block);\n        return snapshot;\n      case 'content_block_delta':\n        {\n          const snapshotContent = snapshot.content.at(event.index);\n          if ((snapshotContent === null || snapshotContent === void 0 ? void 0 : snapshotContent.type) === 'text' && event.delta.type === 'text_delta') {\n            snapshotContent.text += event.delta.text;\n          }\n          return snapshot;\n        }\n      case 'content_block_stop':\n        return snapshot;\n    }\n  }, Symbol.asyncIterator)]() {\n    const pushQueue = [];\n    const readQueue = [];\n    let done = false;\n    this.on('streamEvent', event => {\n      const reader = readQueue.shift();\n      if (reader) {\n        reader.resolve(event);\n      } else {\n        pushQueue.push(event);\n      }\n    });\n    this.on('end', () => {\n      done = true;\n      for (const reader of readQueue) {\n        reader.resolve(undefined);\n      }\n      readQueue.length = 0;\n    });\n    this.on('abort', err => {\n      done = true;\n      for (const reader of readQueue) {\n        reader.reject(err);\n      }\n      readQueue.length = 0;\n    });\n    this.on('error', err => {\n      done = true;\n      for (const reader of readQueue) {\n        reader.reject(err);\n      }\n      readQueue.length = 0;\n    });\n    return {\n      next: async () => {\n        if (!pushQueue.length) {\n          if (done) {\n            return {\n              value: undefined,\n              done: true\n            };\n          }\n          return new Promise((resolve, reject) => readQueue.push({\n            resolve,\n            reject\n          })).then(chunk => chunk ? {\n            value: chunk,\n            done: false\n          } : {\n            value: undefined,\n            done: true\n          });\n        }\n        const chunk = pushQueue.shift();\n        return {\n          value: chunk,\n          done: false\n        };\n      },\n      return: async () => {\n        this.abort();\n        return {\n          value: undefined,\n          done: true\n        };\n      }\n    };\n  }\n  toReadableStream() {\n    const stream = new Stream(this[Symbol.asyncIterator].bind(this), this.controller);\n    return stream.toReadableStream();\n  }\n}","map":{"version":3,"names":["AnthropicError","APIUserAbortError","Stream","MessageStream","constructor","messages","receivedMessages","_MessageStream_currentMessageSnapshot","set","controller","AbortController","_MessageStream_connectedPromise","_MessageStream_resolveConnectedPromise","_MessageStream_rejectConnectedPromise","_MessageStream_endPromise","_MessageStream_resolveEndPromise","_MessageStream_rejectEndPromise","_MessageStream_listeners","_MessageStream_ended","_MessageStream_errored","_MessageStream_aborted","_MessageStream_catchingPromiseCreated","_MessageStream_handleError","error","__classPrivateFieldSet","Error","name","_emit","anthropicError","message","cause","String","Promise","resolve","reject","__classPrivateFieldGet","catch","fromReadableStream","stream","runner","_run","_fromReadableStream","createMessage","params","options","_addMessageParam","_createMessage","_objectSpread","headers","executor","then","_emitFinal","push","_addMessage","emit","arguments","length","undefined","_stream$controller$si","signal","aborted","abort","addEventListener","_MessageStream_instances","_MessageStream_beginRequest","call","create","_connected","_iteratorAbruptCompletion","_didIteratorError","_iteratorError","_iterator","_asyncIterator","_step","next","done","event","value","_MessageStream_addStreamEvent","err","return","_MessageStream_endRequest","ended","errored","on","listener","listeners","off","index","findIndex","l","splice","once","emitted","currentMessage","finalMessage","_MessageStream_getFinalMessage","finalText","_MessageStream_getFinalText","_len","args","Array","_key","filter","forEach","_ref","at","readableStream","_stream$controller$si2","_iteratorAbruptCompletion2","_didIteratorError2","_iteratorError2","_iterator2","_step2","WeakMap","WeakSet","textBlocks","content","block","type","map","text","join","messageSnapshot","_MessageStream_accumulateMessage","delta","snapshot","concat","stop_reason","stop_sequence","content_block","snapshotContent","Symbol","asyncIterator","pushQueue","readQueue","reader","shift","chunk","toReadableStream","bind"],"sources":["/Users/victor/Documents/Sublime/claude_api_project/chat-pwa/node_modules/@anthropic-ai/sdk/src/lib/MessageStream.ts"],"sourcesContent":["import * as Core from \"../core\";\nimport { AnthropicError, APIUserAbortError } from \"../error\";\nimport {\n  ContentBlock,\n  Messages,\n  Message,\n  MessageStreamEvent,\n  MessageParam,\n  MessageCreateParams,\n  MessageStreamParams,\n} from \"../resources/messages\";\nimport { type ReadableStream } from \"../_shims/index\";\nimport { Stream } from \"../streaming\";\n\nexport interface MessageStreamEvents {\n  connect: () => void;\n  streamEvent: (event: MessageStreamEvent, snapshot: Message) => void;\n  text: (textDelta: string, textSnapshot: string) => void;\n  message: (message: Message) => void;\n  contentBlock: (content: ContentBlock) => void;\n  finalMessage: (message: Message) => void;\n  error: (error: AnthropicError) => void;\n  abort: (error: APIUserAbortError) => void;\n  end: () => void;\n}\n\ntype MessageStreamEventListeners<Event extends keyof MessageStreamEvents> = {\n  listener: MessageStreamEvents[Event];\n  once?: boolean;\n}[];\n\nexport class MessageStream implements AsyncIterable<MessageStreamEvent> {\n  messages: MessageParam[] = [];\n  receivedMessages: Message[] = [];\n  #currentMessageSnapshot: Message | undefined;\n\n  controller: AbortController = new AbortController();\n\n  #connectedPromise: Promise<void>;\n  #resolveConnectedPromise: () => void = () => {};\n  #rejectConnectedPromise: (error: AnthropicError) => void = () => {};\n\n  #endPromise: Promise<void>;\n  #resolveEndPromise: () => void = () => {};\n  #rejectEndPromise: (error: AnthropicError) => void = () => {};\n\n  #listeners: { [Event in keyof MessageStreamEvents]?: MessageStreamEventListeners<Event> } = {};\n\n  #ended = false;\n  #errored = false;\n  #aborted = false;\n  #catchingPromiseCreated = false;\n\n  constructor() {\n    this.#connectedPromise = new Promise<void>((resolve, reject) => {\n      this.#resolveConnectedPromise = resolve;\n      this.#rejectConnectedPromise = reject;\n    });\n\n    this.#endPromise = new Promise<void>((resolve, reject) => {\n      this.#resolveEndPromise = resolve;\n      this.#rejectEndPromise = reject;\n    });\n\n    // Don't let these promises cause unhandled rejection errors.\n    // we will manually cause an unhandled rejection error later\n    // if the user hasn't registered any error listener or called\n    // any promise-returning method.\n    this.#connectedPromise.catch(() => {});\n    this.#endPromise.catch(() => {});\n  }\n\n  /**\n   * Intended for use on the frontend, consuming a stream produced with\n   * `.toReadableStream()` on the backend.\n   *\n   * Note that messages sent to the model do not appear in `.on('message')`\n   * in this context.\n   */\n  static fromReadableStream(stream: ReadableStream): MessageStream {\n    const runner = new MessageStream();\n    runner._run(() => runner._fromReadableStream(stream));\n    return runner;\n  }\n\n  static createMessage(\n    messages: Messages,\n    params: MessageStreamParams,\n    options?: Core.RequestOptions,\n  ): MessageStream {\n    const runner = new MessageStream();\n    for (const message of params.messages) {\n      runner._addMessageParam(message);\n    }\n    runner._run(() =>\n      runner._createMessage(\n        messages,\n        { ...params, stream: true },\n        { ...options, headers: { ...options?.headers, 'X-Stainless-Helper-Method': 'stream' } },\n      ),\n    );\n    return runner;\n  }\n\n  protected _run(executor: () => Promise<any>) {\n    executor().then(() => {\n      this._emitFinal();\n      this._emit('end');\n    }, this.#handleError);\n  }\n\n  protected _addMessageParam(message: MessageParam) {\n    this.messages.push(message);\n  }\n\n  protected _addMessage(message: Message, emit = true) {\n    this.receivedMessages.push(message);\n    if (emit) {\n      this._emit('message', message);\n    }\n  }\n\n  protected async _createMessage(\n    messages: Messages,\n    params: MessageCreateParams,\n    options?: Core.RequestOptions,\n  ): Promise<void> {\n    const signal = options?.signal;\n    if (signal) {\n      if (signal.aborted) this.controller.abort();\n      signal.addEventListener('abort', () => this.controller.abort());\n    }\n    this.#beginRequest();\n    const stream = await messages.create(\n      { ...params, stream: true },\n      { ...options, signal: this.controller.signal },\n    );\n    this._connected();\n    for await (const event of stream) {\n      this.#addStreamEvent(event);\n    }\n    if (stream.controller.signal?.aborted) {\n      throw new APIUserAbortError();\n    }\n    this.#endRequest();\n  }\n\n  protected _connected() {\n    if (this.ended) return;\n    this.#resolveConnectedPromise();\n    this._emit('connect');\n  }\n\n  get ended(): boolean {\n    return this.#ended;\n  }\n\n  get errored(): boolean {\n    return this.#errored;\n  }\n\n  get aborted(): boolean {\n    return this.#aborted;\n  }\n\n  abort() {\n    this.controller.abort();\n  }\n\n  /**\n   * Adds the listener function to the end of the listeners array for the event.\n   * No checks are made to see if the listener has already been added. Multiple calls passing\n   * the same combination of event and listener will result in the listener being added, and\n   * called, multiple times.\n   * @returns this MessageStream, so that calls can be chained\n   */\n  on<Event extends keyof MessageStreamEvents>(event: Event, listener: MessageStreamEvents[Event]): this {\n    const listeners: MessageStreamEventListeners<Event> =\n      this.#listeners[event] || (this.#listeners[event] = []);\n    listeners.push({ listener });\n    return this;\n  }\n\n  /**\n   * Removes the specified listener from the listener array for the event.\n   * off() will remove, at most, one instance of a listener from the listener array. If any single\n   * listener has been added multiple times to the listener array for the specified event, then\n   * off() must be called multiple times to remove each instance.\n   * @returns this MessageStream, so that calls can be chained\n   */\n  off<Event extends keyof MessageStreamEvents>(event: Event, listener: MessageStreamEvents[Event]): this {\n    const listeners = this.#listeners[event];\n    if (!listeners) return this;\n    const index = listeners.findIndex((l) => l.listener === listener);\n    if (index >= 0) listeners.splice(index, 1);\n    return this;\n  }\n\n  /**\n   * Adds a one-time listener function for the event. The next time the event is triggered,\n   * this listener is removed and then invoked.\n   * @returns this MessageStream, so that calls can be chained\n   */\n  once<Event extends keyof MessageStreamEvents>(event: Event, listener: MessageStreamEvents[Event]): this {\n    const listeners: MessageStreamEventListeners<Event> =\n      this.#listeners[event] || (this.#listeners[event] = []);\n    listeners.push({ listener, once: true });\n    return this;\n  }\n\n  /**\n   * This is similar to `.once()`, but returns a Promise that resolves the next time\n   * the event is triggered, instead of calling a listener callback.\n   * @returns a Promise that resolves the next time given event is triggered,\n   * or rejects if an error is emitted.  (If you request the 'error' event,\n   * returns a promise that resolves with the error).\n   *\n   * Example:\n   *\n   *   const message = await stream.emitted('message') // rejects if the stream errors\n   */\n  emitted<Event extends keyof MessageStreamEvents>(\n    event: Event,\n  ): Promise<\n    Parameters<MessageStreamEvents[Event]> extends [infer Param] ? Param\n    : Parameters<MessageStreamEvents[Event]> extends [] ? void\n    : Parameters<MessageStreamEvents[Event]>\n  > {\n    return new Promise((resolve, reject) => {\n      this.#catchingPromiseCreated = true;\n      if (event !== 'error') this.once('error', reject);\n      this.once(event, resolve as any);\n    });\n  }\n\n  async done(): Promise<void> {\n    this.#catchingPromiseCreated = true;\n    await this.#endPromise;\n  }\n\n  get currentMessage(): Message | undefined {\n    return this.#currentMessageSnapshot;\n  }\n\n  #getFinalMessage(): Message {\n    if (this.receivedMessages.length === 0) {\n      throw new AnthropicError('stream ended without producing a Message with role=assistant');\n    }\n    return this.receivedMessages.at(-1)!;\n  }\n\n  /**\n   * @returns a promise that resolves with the the final assistant Message response,\n   * or rejects if an error occurred or the stream ended prematurely without producing a Message.\n   */\n  async finalMessage(): Promise<Message> {\n    await this.done();\n    return this.#getFinalMessage();\n  }\n\n  #getFinalText(): string {\n    if (this.receivedMessages.length === 0) {\n      throw new AnthropicError('stream ended without producing a Message with role=assistant');\n    }\n    const textBlocks = this.receivedMessages\n      .at(-1)!\n      .content.filter((block) => block.type === 'text')\n      .map((block) => block.text);\n    if (textBlocks.length === 0) {\n      throw new AnthropicError('stream ended without producing a content block with type=text');\n    }\n    return textBlocks.join(' ');\n  }\n\n  /**\n   * @returns a promise that resolves with the the final assistant Message's text response, concatenated\n   * together if there are more than one text blocks.\n   * Rejects if an error occurred or the stream ended prematurely without producing a Message.\n   */\n  async finalText(): Promise<string> {\n    await this.done();\n    return this.#getFinalText();\n  }\n\n  #handleError = (error: unknown) => {\n    this.#errored = true;\n    if (error instanceof Error && error.name === 'AbortError') {\n      error = new APIUserAbortError();\n    }\n    if (error instanceof APIUserAbortError) {\n      this.#aborted = true;\n      return this._emit('abort', error);\n    }\n    if (error instanceof AnthropicError) {\n      return this._emit('error', error);\n    }\n    if (error instanceof Error) {\n      const anthropicError: AnthropicError = new AnthropicError(error.message);\n      // @ts-ignore\n      anthropicError.cause = error;\n      return this._emit('error', anthropicError);\n    }\n    return this._emit('error', new AnthropicError(String(error)));\n  };\n\n  protected _emit<Event extends keyof MessageStreamEvents>(\n    event: Event,\n    ...args: Parameters<MessageStreamEvents[Event]>\n  ) {\n    // make sure we don't emit any MessageStreamEvents after end\n    if (this.#ended) return;\n\n    if (event === 'end') {\n      this.#ended = true;\n      this.#resolveEndPromise();\n    }\n\n    const listeners: MessageStreamEventListeners<Event> | undefined = this.#listeners[event];\n    if (listeners) {\n      this.#listeners[event] = listeners.filter((l) => !l.once) as any;\n      listeners.forEach(({ listener }: any) => listener(...args));\n    }\n\n    if (event === 'abort') {\n      const error = args[0] as APIUserAbortError;\n      if (!this.#catchingPromiseCreated && !listeners?.length) {\n        Promise.reject(error);\n      }\n      this.#rejectConnectedPromise(error);\n      this.#rejectEndPromise(error);\n      this._emit('end');\n      return;\n    }\n\n    if (event === 'error') {\n      // NOTE: _emit('error', error) should only be called from #handleError().\n\n      const error = args[0] as AnthropicError;\n      if (!this.#catchingPromiseCreated && !listeners?.length) {\n        // Trigger an unhandled rejection if the user hasn't registered any error handlers.\n        // If you are seeing stack traces here, make sure to handle errors via either:\n        // - runner.on('error', () => ...)\n        // - await runner.done()\n        // - await runner.final...()\n        // - etc.\n        Promise.reject(error);\n      }\n      this.#rejectConnectedPromise(error);\n      this.#rejectEndPromise(error);\n      this._emit('end');\n    }\n  }\n\n  protected _emitFinal() {\n    const finalMessage = this.receivedMessages.at(-1);\n    if (finalMessage) {\n      this._emit('finalMessage', this.#getFinalMessage());\n    }\n  }\n\n  #beginRequest() {\n    if (this.ended) return;\n    this.#currentMessageSnapshot = undefined;\n  }\n  #addStreamEvent(event: MessageStreamEvent) {\n    if (this.ended) return;\n    const messageSnapshot = this.#accumulateMessage(event);\n    this._emit('streamEvent', event, messageSnapshot);\n\n    switch (event.type) {\n      case 'content_block_delta': {\n        if (event.delta.type === 'text_delta') {\n          this._emit('text', event.delta.text, messageSnapshot.content.at(-1)!.text || '');\n        }\n        break;\n      }\n      case 'message_stop': {\n        this._addMessageParam(messageSnapshot);\n        this._addMessage(messageSnapshot, true);\n        break;\n      }\n      case 'content_block_stop': {\n        this._emit('contentBlock', messageSnapshot.content.at(-1)!);\n        break;\n      }\n      case 'message_start': {\n        this.#currentMessageSnapshot = messageSnapshot;\n        break;\n      }\n      case 'content_block_start':\n      case 'message_delta':\n        break;\n    }\n  }\n  #endRequest(): Message {\n    if (this.ended) {\n      throw new AnthropicError(`stream has ended, this shouldn't happen`);\n    }\n    const snapshot = this.#currentMessageSnapshot;\n    if (!snapshot) {\n      throw new AnthropicError(`request ended without sending any chunks`);\n    }\n    this.#currentMessageSnapshot = undefined;\n    return snapshot;\n  }\n\n  protected async _fromReadableStream(\n    readableStream: ReadableStream,\n    options?: Core.RequestOptions,\n  ): Promise<void> {\n    const signal = options?.signal;\n    if (signal) {\n      if (signal.aborted) this.controller.abort();\n      signal.addEventListener('abort', () => this.controller.abort());\n    }\n    this.#beginRequest();\n    this._connected();\n    const stream = Stream.fromReadableStream<MessageStreamEvent>(readableStream, this.controller);\n    for await (const event of stream) {\n      this.#addStreamEvent(event);\n    }\n    if (stream.controller.signal?.aborted) {\n      throw new APIUserAbortError();\n    }\n    this.#endRequest();\n  }\n\n  /**\n   * Mutates this.#currentMessage with the current event. Handling the accumulation of multiple messages\n   * will be needed to be handled by the caller, this method will throw if you try to accumulate for multiple\n   * messages.\n   */\n  #accumulateMessage(event: MessageStreamEvent): Message {\n    let snapshot = this.#currentMessageSnapshot;\n\n    if (event.type === 'message_start') {\n      if (snapshot) {\n        throw new AnthropicError(`Unexpected event order, got ${event.type} before receiving \"message_stop\"`);\n      }\n      return event.message;\n    }\n\n    if (!snapshot) {\n      throw new AnthropicError(`Unexpected event order, got ${event.type} before \"message_start\"`);\n    }\n\n    switch (event.type) {\n      case 'message_stop':\n        return snapshot;\n      case 'message_delta':\n        snapshot.stop_reason = event.delta.stop_reason;\n        snapshot.stop_sequence = event.delta.stop_sequence;\n        return snapshot;\n      case 'content_block_start':\n        snapshot.content.push(event.content_block);\n        return snapshot;\n      case 'content_block_delta': {\n        const snapshotContent = snapshot.content.at(event.index);\n        if (snapshotContent?.type === 'text' && event.delta.type === 'text_delta') {\n          snapshotContent.text += event.delta.text;\n        }\n        return snapshot;\n      }\n      case 'content_block_stop':\n        return snapshot;\n    }\n  }\n\n  [Symbol.asyncIterator](): AsyncIterator<MessageStreamEvent> {\n    const pushQueue: MessageStreamEvent[] = [];\n    const readQueue: {\n      resolve: (chunk: MessageStreamEvent | undefined) => void;\n      reject: (error: unknown) => void;\n    }[] = [];\n    let done = false;\n\n    this.on('streamEvent', (event) => {\n      const reader = readQueue.shift();\n      if (reader) {\n        reader.resolve(event);\n      } else {\n        pushQueue.push(event);\n      }\n    });\n\n    this.on('end', () => {\n      done = true;\n      for (const reader of readQueue) {\n        reader.resolve(undefined);\n      }\n      readQueue.length = 0;\n    });\n\n    this.on('abort', (err) => {\n      done = true;\n      for (const reader of readQueue) {\n        reader.reject(err);\n      }\n      readQueue.length = 0;\n    });\n\n    this.on('error', (err) => {\n      done = true;\n      for (const reader of readQueue) {\n        reader.reject(err);\n      }\n      readQueue.length = 0;\n    });\n\n    return {\n      next: async (): Promise<IteratorResult<MessageStreamEvent>> => {\n        if (!pushQueue.length) {\n          if (done) {\n            return { value: undefined, done: true };\n          }\n          return new Promise<MessageStreamEvent | undefined>((resolve, reject) =>\n            readQueue.push({ resolve, reject }),\n          ).then((chunk) => (chunk ? { value: chunk, done: false } : { value: undefined, done: true }));\n        }\n        const chunk = pushQueue.shift()!;\n        return { value: chunk, done: false };\n      },\n      return: async () => {\n        this.abort();\n        return { value: undefined, done: true };\n      },\n    };\n  }\n\n  toReadableStream(): ReadableStream {\n    const stream = new Stream(this[Symbol.asyncIterator].bind(this), this.controller);\n    return stream.toReadableStream();\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}