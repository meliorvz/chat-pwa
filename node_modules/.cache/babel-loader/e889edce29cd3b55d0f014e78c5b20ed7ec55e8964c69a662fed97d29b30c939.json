{"ast":null,"code":"import _awaitAsyncGenerator from \"/Users/victor/Documents/Sublime/claude_api_project/chat-pwa/node_modules/@babel/runtime/helpers/esm/awaitAsyncGenerator.js\";\nimport _wrapAsyncGenerator from \"/Users/victor/Documents/Sublime/claude_api_project/chat-pwa/node_modules/@babel/runtime/helpers/esm/wrapAsyncGenerator.js\";\nimport _asyncIterator from \"/Users/victor/Documents/Sublime/claude_api_project/chat-pwa/node_modules/@babel/runtime/helpers/esm/asyncIterator.js\";\nimport { ReadableStream } from \"./_shims/index.mjs\";\nimport { OpenAIError } from \"./error.mjs\";\nimport { LineDecoder } from \"./internal/decoders/line.mjs\";\nimport { APIError } from \"./error.mjs\";\nexport class Stream {\n  constructor(iterator, controller) {\n    this.iterator = iterator;\n    this.controller = controller;\n  }\n  static fromSSEResponse(response, controller) {\n    let consumed = false;\n    function iterator() {\n      return _iterator2.apply(this, arguments);\n    }\n    function _iterator2() {\n      _iterator2 = _wrapAsyncGenerator(function* () {\n        if (consumed) {\n          throw new Error('Cannot iterate over a consumed stream, use `.tee()` to split the stream.');\n        }\n        consumed = true;\n        let done = false;\n        try {\n          var _iteratorAbruptCompletion = false;\n          var _didIteratorError = false;\n          var _iteratorError;\n          try {\n            for (var _iterator = _asyncIterator(_iterSSEMessages(response, controller)), _step; _iteratorAbruptCompletion = !(_step = yield _awaitAsyncGenerator(_iterator.next())).done; _iteratorAbruptCompletion = false) {\n              const sse = _step.value;\n              {\n                if (done) continue;\n                if (sse.data.startsWith('[DONE]')) {\n                  done = true;\n                  continue;\n                }\n                if (sse.event === null) {\n                  let data;\n                  try {\n                    data = JSON.parse(sse.data);\n                  } catch (e) {\n                    console.error(\"Could not parse message into JSON:\", sse.data);\n                    console.error(\"From chunk:\", sse.raw);\n                    throw e;\n                  }\n                  if (data && data.error) {\n                    throw new APIError(undefined, data.error, undefined, undefined);\n                  }\n                  yield data;\n                } else {\n                  let data;\n                  try {\n                    data = JSON.parse(sse.data);\n                  } catch (e) {\n                    console.error(\"Could not parse message into JSON:\", sse.data);\n                    console.error(\"From chunk:\", sse.raw);\n                    throw e;\n                  }\n                  // TODO: Is this where the error should be thrown?\n                  if (sse.event == 'error') {\n                    throw new APIError(undefined, data.error, data.message, undefined);\n                  }\n                  yield {\n                    event: sse.event,\n                    data: data\n                  };\n                }\n              }\n            }\n          } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n          } finally {\n            try {\n              if (_iteratorAbruptCompletion && _iterator.return != null) {\n                yield _awaitAsyncGenerator(_iterator.return());\n              }\n            } finally {\n              if (_didIteratorError) {\n                throw _iteratorError;\n              }\n            }\n          }\n          done = true;\n        } catch (e) {\n          // If the user calls `stream.controller.abort()`, we should exit without throwing.\n          if (e instanceof Error && e.name === 'AbortError') return;\n          throw e;\n        } finally {\n          // If the user `break`s, abort the ongoing request.\n          if (!done) controller.abort();\n        }\n      });\n      return _iterator2.apply(this, arguments);\n    }\n    return new Stream(iterator, controller);\n  }\n  /**\n   * Generates a Stream from a newline-separated ReadableStream\n   * where each item is a JSON value.\n   */\n  static fromReadableStream(readableStream, controller) {\n    let consumed = false;\n    function iterLines() {\n      return _iterLines.apply(this, arguments);\n    }\n    function _iterLines() {\n      _iterLines = _wrapAsyncGenerator(function* () {\n        const lineDecoder = new LineDecoder();\n        const iter = readableStreamAsyncIterable(readableStream);\n        var _iteratorAbruptCompletion2 = false;\n        var _didIteratorError2 = false;\n        var _iteratorError2;\n        try {\n          for (var _iterator3 = _asyncIterator(iter), _step2; _iteratorAbruptCompletion2 = !(_step2 = yield _awaitAsyncGenerator(_iterator3.next())).done; _iteratorAbruptCompletion2 = false) {\n            const chunk = _step2.value;\n            {\n              for (const line of lineDecoder.decode(chunk)) {\n                yield line;\n              }\n            }\n          }\n        } catch (err) {\n          _didIteratorError2 = true;\n          _iteratorError2 = err;\n        } finally {\n          try {\n            if (_iteratorAbruptCompletion2 && _iterator3.return != null) {\n              yield _awaitAsyncGenerator(_iterator3.return());\n            }\n          } finally {\n            if (_didIteratorError2) {\n              throw _iteratorError2;\n            }\n          }\n        }\n        for (const line of lineDecoder.flush()) {\n          yield line;\n        }\n      });\n      return _iterLines.apply(this, arguments);\n    }\n    function iterator() {\n      return _iterator5.apply(this, arguments);\n    }\n    function _iterator5() {\n      _iterator5 = _wrapAsyncGenerator(function* () {\n        if (consumed) {\n          throw new Error('Cannot iterate over a consumed stream, use `.tee()` to split the stream.');\n        }\n        consumed = true;\n        let done = false;\n        try {\n          var _iteratorAbruptCompletion3 = false;\n          var _didIteratorError3 = false;\n          var _iteratorError3;\n          try {\n            for (var _iterator4 = _asyncIterator(iterLines()), _step3; _iteratorAbruptCompletion3 = !(_step3 = yield _awaitAsyncGenerator(_iterator4.next())).done; _iteratorAbruptCompletion3 = false) {\n              const line = _step3.value;\n              {\n                if (done) continue;\n                if (line) yield JSON.parse(line);\n              }\n            }\n          } catch (err) {\n            _didIteratorError3 = true;\n            _iteratorError3 = err;\n          } finally {\n            try {\n              if (_iteratorAbruptCompletion3 && _iterator4.return != null) {\n                yield _awaitAsyncGenerator(_iterator4.return());\n              }\n            } finally {\n              if (_didIteratorError3) {\n                throw _iteratorError3;\n              }\n            }\n          }\n          done = true;\n        } catch (e) {\n          // If the user calls `stream.controller.abort()`, we should exit without throwing.\n          if (e instanceof Error && e.name === 'AbortError') return;\n          throw e;\n        } finally {\n          // If the user `break`s, abort the ongoing request.\n          if (!done) controller.abort();\n        }\n      });\n      return _iterator5.apply(this, arguments);\n    }\n    return new Stream(iterator, controller);\n  }\n  [Symbol.asyncIterator]() {\n    return this.iterator();\n  }\n  /**\n   * Splits the stream into two streams which can be\n   * independently read from at different speeds.\n   */\n  tee() {\n    const left = [];\n    const right = [];\n    const iterator = this.iterator();\n    const teeIterator = queue => {\n      return {\n        next: () => {\n          if (queue.length === 0) {\n            const result = iterator.next();\n            left.push(result);\n            right.push(result);\n          }\n          return queue.shift();\n        }\n      };\n    };\n    return [new Stream(() => teeIterator(left), this.controller), new Stream(() => teeIterator(right), this.controller)];\n  }\n  /**\n   * Converts this stream to a newline-separated ReadableStream of\n   * JSON stringified values in the stream\n   * which can be turned back into a Stream with `Stream.fromReadableStream()`.\n   */\n  toReadableStream() {\n    const self = this;\n    let iter;\n    const encoder = new TextEncoder();\n    return new ReadableStream({\n      async start() {\n        iter = self[Symbol.asyncIterator]();\n      },\n      async pull(ctrl) {\n        try {\n          const {\n            value,\n            done\n          } = await iter.next();\n          if (done) return ctrl.close();\n          const bytes = encoder.encode(JSON.stringify(value) + '\\n');\n          ctrl.enqueue(bytes);\n        } catch (err) {\n          ctrl.error(err);\n        }\n      },\n      async cancel() {\n        var _iter$return, _iter;\n        await ((_iter$return = (_iter = iter).return) === null || _iter$return === void 0 ? void 0 : _iter$return.call(_iter));\n      }\n    });\n  }\n}\nexport function _iterSSEMessages(_x, _x2) {\n  return _iterSSEMessages2.apply(this, arguments);\n}\n/**\n * Given an async iterable iterator, iterates over it and yields full\n * SSE chunks, i.e. yields when a double new-line is encountered.\n */\nfunction _iterSSEMessages2() {\n  _iterSSEMessages2 = _wrapAsyncGenerator(function* (response, controller) {\n    if (!response.body) {\n      controller.abort();\n      throw new OpenAIError(\"Attempted to iterate over a response with no body\");\n    }\n    const sseDecoder = new SSEDecoder();\n    const lineDecoder = new LineDecoder();\n    const iter = readableStreamAsyncIterable(response.body);\n    var _iteratorAbruptCompletion4 = false;\n    var _didIteratorError4 = false;\n    var _iteratorError4;\n    try {\n      for (var _iterator6 = _asyncIterator(iterSSEChunks(iter)), _step4; _iteratorAbruptCompletion4 = !(_step4 = yield _awaitAsyncGenerator(_iterator6.next())).done; _iteratorAbruptCompletion4 = false) {\n        const sseChunk = _step4.value;\n        {\n          for (const line of lineDecoder.decode(sseChunk)) {\n            const sse = sseDecoder.decode(line);\n            if (sse) yield sse;\n          }\n        }\n      }\n    } catch (err) {\n      _didIteratorError4 = true;\n      _iteratorError4 = err;\n    } finally {\n      try {\n        if (_iteratorAbruptCompletion4 && _iterator6.return != null) {\n          yield _awaitAsyncGenerator(_iterator6.return());\n        }\n      } finally {\n        if (_didIteratorError4) {\n          throw _iteratorError4;\n        }\n      }\n    }\n    for (const line of lineDecoder.flush()) {\n      const sse = sseDecoder.decode(line);\n      if (sse) yield sse;\n    }\n  });\n  return _iterSSEMessages2.apply(this, arguments);\n}\nfunction iterSSEChunks(_x3) {\n  return _iterSSEChunks.apply(this, arguments);\n}\nfunction _iterSSEChunks() {\n  _iterSSEChunks = _wrapAsyncGenerator(function* (iterator) {\n    let data = new Uint8Array();\n    var _iteratorAbruptCompletion5 = false;\n    var _didIteratorError5 = false;\n    var _iteratorError5;\n    try {\n      for (var _iterator7 = _asyncIterator(iterator), _step5; _iteratorAbruptCompletion5 = !(_step5 = yield _awaitAsyncGenerator(_iterator7.next())).done; _iteratorAbruptCompletion5 = false) {\n        const chunk = _step5.value;\n        {\n          if (chunk == null) {\n            continue;\n          }\n          const binaryChunk = chunk instanceof ArrayBuffer ? new Uint8Array(chunk) : typeof chunk === 'string' ? new TextEncoder().encode(chunk) : chunk;\n          let newData = new Uint8Array(data.length + binaryChunk.length);\n          newData.set(data);\n          newData.set(binaryChunk, data.length);\n          data = newData;\n          let patternIndex;\n          while ((patternIndex = findDoubleNewlineIndex(data)) !== -1) {\n            yield data.slice(0, patternIndex);\n            data = data.slice(patternIndex);\n          }\n        }\n      }\n    } catch (err) {\n      _didIteratorError5 = true;\n      _iteratorError5 = err;\n    } finally {\n      try {\n        if (_iteratorAbruptCompletion5 && _iterator7.return != null) {\n          yield _awaitAsyncGenerator(_iterator7.return());\n        }\n      } finally {\n        if (_didIteratorError5) {\n          throw _iteratorError5;\n        }\n      }\n    }\n    if (data.length > 0) {\n      yield data;\n    }\n  });\n  return _iterSSEChunks.apply(this, arguments);\n}\nfunction findDoubleNewlineIndex(buffer) {\n  // This function searches the buffer for the end patterns (\\r\\r, \\n\\n, \\r\\n\\r\\n)\n  // and returns the index right after the first occurrence of any pattern,\n  // or -1 if none of the patterns are found.\n  const newline = 0x0a; // \\n\n  const carriage = 0x0d; // \\r\n  for (let i = 0; i < buffer.length - 2; i++) {\n    if (buffer[i] === newline && buffer[i + 1] === newline) {\n      // \\n\\n\n      return i + 2;\n    }\n    if (buffer[i] === carriage && buffer[i + 1] === carriage) {\n      // \\r\\r\n      return i + 2;\n    }\n    if (buffer[i] === carriage && buffer[i + 1] === newline && i + 3 < buffer.length && buffer[i + 2] === carriage && buffer[i + 3] === newline) {\n      // \\r\\n\\r\\n\n      return i + 4;\n    }\n  }\n  return -1;\n}\nclass SSEDecoder {\n  constructor() {\n    this.event = null;\n    this.data = [];\n    this.chunks = [];\n  }\n  decode(line) {\n    if (line.endsWith('\\r')) {\n      line = line.substring(0, line.length - 1);\n    }\n    if (!line) {\n      // empty line and we didn't previously encounter any messages\n      if (!this.event && !this.data.length) return null;\n      const sse = {\n        event: this.event,\n        data: this.data.join('\\n'),\n        raw: this.chunks\n      };\n      this.event = null;\n      this.data = [];\n      this.chunks = [];\n      return sse;\n    }\n    this.chunks.push(line);\n    if (line.startsWith(':')) {\n      return null;\n    }\n    let [fieldname, _, value] = partition(line, ':');\n    if (value.startsWith(' ')) {\n      value = value.substring(1);\n    }\n    if (fieldname === 'event') {\n      this.event = value;\n    } else if (fieldname === 'data') {\n      this.data.push(value);\n    }\n    return null;\n  }\n}\n/** This is an internal helper function that's just used for testing */\nexport function _decodeChunks(chunks) {\n  const decoder = new LineDecoder();\n  const lines = [];\n  for (const chunk of chunks) {\n    lines.push(...decoder.decode(chunk));\n  }\n  return lines;\n}\nfunction partition(str, delimiter) {\n  const index = str.indexOf(delimiter);\n  if (index !== -1) {\n    return [str.substring(0, index), delimiter, str.substring(index + delimiter.length)];\n  }\n  return [str, '', ''];\n}\n/**\n * Most browsers don't yet have async iterable support for ReadableStream,\n * and Node has a very different way of reading bytes from its \"ReadableStream\".\n *\n * This polyfill was pulled from https://github.com/MattiasBuelens/web-streams-polyfill/pull/122#issuecomment-1627354490\n */\nexport function readableStreamAsyncIterable(stream) {\n  if (stream[Symbol.asyncIterator]) return stream;\n  const reader = stream.getReader();\n  return {\n    async next() {\n      try {\n        const result = await reader.read();\n        if (result !== null && result !== void 0 && result.done) reader.releaseLock(); // release lock when stream becomes closed\n        return result;\n      } catch (e) {\n        reader.releaseLock(); // release lock when stream becomes errored\n        throw e;\n      }\n    },\n    async return() {\n      const cancelPromise = reader.cancel();\n      reader.releaseLock();\n      await cancelPromise;\n      return {\n        done: true,\n        value: undefined\n      };\n    },\n    [Symbol.asyncIterator]() {\n      return this;\n    }\n  };\n}","map":{"version":3,"names":["ReadableStream","OpenAIError","LineDecoder","APIError","Stream","constructor","iterator","controller","fromSSEResponse","response","consumed","_iterator2","apply","arguments","_wrapAsyncGenerator","Error","done","_iteratorAbruptCompletion","_didIteratorError","_iteratorError","_iterator","_asyncIterator","_iterSSEMessages","_step","_awaitAsyncGenerator","next","sse","value","data","startsWith","event","JSON","parse","e","console","error","raw","undefined","message","err","return","name","abort","fromReadableStream","readableStream","iterLines","_iterLines","lineDecoder","iter","readableStreamAsyncIterable","_iteratorAbruptCompletion2","_didIteratorError2","_iteratorError2","_iterator3","_step2","chunk","line","decode","flush","_iterator5","_iteratorAbruptCompletion3","_didIteratorError3","_iteratorError3","_iterator4","_step3","Symbol","asyncIterator","tee","left","right","teeIterator","queue","length","result","push","shift","toReadableStream","self","encoder","TextEncoder","start","pull","ctrl","close","bytes","encode","stringify","enqueue","cancel","_iter$return","_iter","call","_x","_x2","_iterSSEMessages2","body","sseDecoder","SSEDecoder","_iteratorAbruptCompletion4","_didIteratorError4","_iteratorError4","_iterator6","iterSSEChunks","_step4","sseChunk","_x3","_iterSSEChunks","Uint8Array","_iteratorAbruptCompletion5","_didIteratorError5","_iteratorError5","_iterator7","_step5","binaryChunk","ArrayBuffer","newData","set","patternIndex","findDoubleNewlineIndex","slice","buffer","newline","carriage","i","chunks","endsWith","substring","join","fieldname","_","partition","_decodeChunks","decoder","lines","str","delimiter","index","indexOf","stream","reader","getReader","read","releaseLock","cancelPromise"],"sources":["/Users/victor/Documents/Sublime/claude_api_project/chat-pwa/node_modules/openai/src/streaming.ts"],"sourcesContent":["import { ReadableStream, type Response } from './_shims/index';\nimport { OpenAIError } from './error';\nimport { LineDecoder } from './internal/decoders/line';\n\nimport { APIError } from './error';\n\ntype Bytes = string | ArrayBuffer | Uint8Array | Buffer | null | undefined;\n\nexport type ServerSentEvent = {\n  event: string | null;\n  data: string;\n  raw: string[];\n};\n\nexport class Stream<Item> implements AsyncIterable<Item> {\n  controller: AbortController;\n\n  constructor(\n    private iterator: () => AsyncIterator<Item>,\n    controller: AbortController,\n  ) {\n    this.controller = controller;\n  }\n\n  static fromSSEResponse<Item>(response: Response, controller: AbortController): Stream<Item> {\n    let consumed = false;\n\n    async function* iterator(): AsyncIterator<Item, any, undefined> {\n      if (consumed) {\n        throw new Error('Cannot iterate over a consumed stream, use `.tee()` to split the stream.');\n      }\n      consumed = true;\n      let done = false;\n      try {\n        for await (const sse of _iterSSEMessages(response, controller)) {\n          if (done) continue;\n\n          if (sse.data.startsWith('[DONE]')) {\n            done = true;\n            continue;\n          }\n\n          if (sse.event === null) {\n            let data;\n\n            try {\n              data = JSON.parse(sse.data);\n            } catch (e) {\n              console.error(`Could not parse message into JSON:`, sse.data);\n              console.error(`From chunk:`, sse.raw);\n              throw e;\n            }\n\n            if (data && data.error) {\n              throw new APIError(undefined, data.error, undefined, undefined);\n            }\n\n            yield data;\n          } else {\n            let data;\n            try {\n              data = JSON.parse(sse.data);\n            } catch (e) {\n              console.error(`Could not parse message into JSON:`, sse.data);\n              console.error(`From chunk:`, sse.raw);\n              throw e;\n            }\n            // TODO: Is this where the error should be thrown?\n            if (sse.event == 'error') {\n              throw new APIError(undefined, data.error, data.message, undefined);\n            }\n            yield { event: sse.event, data: data } as any;\n          }\n        }\n        done = true;\n      } catch (e) {\n        // If the user calls `stream.controller.abort()`, we should exit without throwing.\n        if (e instanceof Error && e.name === 'AbortError') return;\n        throw e;\n      } finally {\n        // If the user `break`s, abort the ongoing request.\n        if (!done) controller.abort();\n      }\n    }\n\n    return new Stream(iterator, controller);\n  }\n\n  /**\n   * Generates a Stream from a newline-separated ReadableStream\n   * where each item is a JSON value.\n   */\n  static fromReadableStream<Item>(readableStream: ReadableStream, controller: AbortController): Stream<Item> {\n    let consumed = false;\n\n    async function* iterLines(): AsyncGenerator<string, void, unknown> {\n      const lineDecoder = new LineDecoder();\n\n      const iter = readableStreamAsyncIterable<Bytes>(readableStream);\n      for await (const chunk of iter) {\n        for (const line of lineDecoder.decode(chunk)) {\n          yield line;\n        }\n      }\n\n      for (const line of lineDecoder.flush()) {\n        yield line;\n      }\n    }\n\n    async function* iterator(): AsyncIterator<Item, any, undefined> {\n      if (consumed) {\n        throw new Error('Cannot iterate over a consumed stream, use `.tee()` to split the stream.');\n      }\n      consumed = true;\n      let done = false;\n      try {\n        for await (const line of iterLines()) {\n          if (done) continue;\n          if (line) yield JSON.parse(line);\n        }\n        done = true;\n      } catch (e) {\n        // If the user calls `stream.controller.abort()`, we should exit without throwing.\n        if (e instanceof Error && e.name === 'AbortError') return;\n        throw e;\n      } finally {\n        // If the user `break`s, abort the ongoing request.\n        if (!done) controller.abort();\n      }\n    }\n\n    return new Stream(iterator, controller);\n  }\n\n  [Symbol.asyncIterator](): AsyncIterator<Item> {\n    return this.iterator();\n  }\n\n  /**\n   * Splits the stream into two streams which can be\n   * independently read from at different speeds.\n   */\n  tee(): [Stream<Item>, Stream<Item>] {\n    const left: Array<Promise<IteratorResult<Item>>> = [];\n    const right: Array<Promise<IteratorResult<Item>>> = [];\n    const iterator = this.iterator();\n\n    const teeIterator = (queue: Array<Promise<IteratorResult<Item>>>): AsyncIterator<Item> => {\n      return {\n        next: () => {\n          if (queue.length === 0) {\n            const result = iterator.next();\n            left.push(result);\n            right.push(result);\n          }\n          return queue.shift()!;\n        },\n      };\n    };\n\n    return [\n      new Stream(() => teeIterator(left), this.controller),\n      new Stream(() => teeIterator(right), this.controller),\n    ];\n  }\n\n  /**\n   * Converts this stream to a newline-separated ReadableStream of\n   * JSON stringified values in the stream\n   * which can be turned back into a Stream with `Stream.fromReadableStream()`.\n   */\n  toReadableStream(): ReadableStream {\n    const self = this;\n    let iter: AsyncIterator<Item>;\n    const encoder = new TextEncoder();\n\n    return new ReadableStream({\n      async start() {\n        iter = self[Symbol.asyncIterator]();\n      },\n      async pull(ctrl: any) {\n        try {\n          const { value, done } = await iter.next();\n          if (done) return ctrl.close();\n\n          const bytes = encoder.encode(JSON.stringify(value) + '\\n');\n\n          ctrl.enqueue(bytes);\n        } catch (err) {\n          ctrl.error(err);\n        }\n      },\n      async cancel() {\n        await iter.return?.();\n      },\n    });\n  }\n}\n\nexport async function* _iterSSEMessages(\n  response: Response,\n  controller: AbortController,\n): AsyncGenerator<ServerSentEvent, void, unknown> {\n  if (!response.body) {\n    controller.abort();\n    throw new OpenAIError(`Attempted to iterate over a response with no body`);\n  }\n\n  const sseDecoder = new SSEDecoder();\n  const lineDecoder = new LineDecoder();\n\n  const iter = readableStreamAsyncIterable<Bytes>(response.body);\n  for await (const sseChunk of iterSSEChunks(iter)) {\n    for (const line of lineDecoder.decode(sseChunk)) {\n      const sse = sseDecoder.decode(line);\n      if (sse) yield sse;\n    }\n  }\n\n  for (const line of lineDecoder.flush()) {\n    const sse = sseDecoder.decode(line);\n    if (sse) yield sse;\n  }\n}\n\n/**\n * Given an async iterable iterator, iterates over it and yields full\n * SSE chunks, i.e. yields when a double new-line is encountered.\n */\nasync function* iterSSEChunks(iterator: AsyncIterableIterator<Bytes>): AsyncGenerator<Uint8Array> {\n  let data = new Uint8Array();\n\n  for await (const chunk of iterator) {\n    if (chunk == null) {\n      continue;\n    }\n\n    const binaryChunk =\n      chunk instanceof ArrayBuffer ? new Uint8Array(chunk)\n      : typeof chunk === 'string' ? new TextEncoder().encode(chunk)\n      : chunk;\n\n    let newData = new Uint8Array(data.length + binaryChunk.length);\n    newData.set(data);\n    newData.set(binaryChunk, data.length);\n    data = newData;\n\n    let patternIndex;\n    while ((patternIndex = findDoubleNewlineIndex(data)) !== -1) {\n      yield data.slice(0, patternIndex);\n      data = data.slice(patternIndex);\n    }\n  }\n\n  if (data.length > 0) {\n    yield data;\n  }\n}\n\nfunction findDoubleNewlineIndex(buffer: Uint8Array): number {\n  // This function searches the buffer for the end patterns (\\r\\r, \\n\\n, \\r\\n\\r\\n)\n  // and returns the index right after the first occurrence of any pattern,\n  // or -1 if none of the patterns are found.\n  const newline = 0x0a; // \\n\n  const carriage = 0x0d; // \\r\n\n  for (let i = 0; i < buffer.length - 2; i++) {\n    if (buffer[i] === newline && buffer[i + 1] === newline) {\n      // \\n\\n\n      return i + 2;\n    }\n    if (buffer[i] === carriage && buffer[i + 1] === carriage) {\n      // \\r\\r\n      return i + 2;\n    }\n    if (\n      buffer[i] === carriage &&\n      buffer[i + 1] === newline &&\n      i + 3 < buffer.length &&\n      buffer[i + 2] === carriage &&\n      buffer[i + 3] === newline\n    ) {\n      // \\r\\n\\r\\n\n      return i + 4;\n    }\n  }\n\n  return -1;\n}\n\nclass SSEDecoder {\n  private data: string[];\n  private event: string | null;\n  private chunks: string[];\n\n  constructor() {\n    this.event = null;\n    this.data = [];\n    this.chunks = [];\n  }\n\n  decode(line: string) {\n    if (line.endsWith('\\r')) {\n      line = line.substring(0, line.length - 1);\n    }\n\n    if (!line) {\n      // empty line and we didn't previously encounter any messages\n      if (!this.event && !this.data.length) return null;\n\n      const sse: ServerSentEvent = {\n        event: this.event,\n        data: this.data.join('\\n'),\n        raw: this.chunks,\n      };\n\n      this.event = null;\n      this.data = [];\n      this.chunks = [];\n\n      return sse;\n    }\n\n    this.chunks.push(line);\n\n    if (line.startsWith(':')) {\n      return null;\n    }\n\n    let [fieldname, _, value] = partition(line, ':');\n\n    if (value.startsWith(' ')) {\n      value = value.substring(1);\n    }\n\n    if (fieldname === 'event') {\n      this.event = value;\n    } else if (fieldname === 'data') {\n      this.data.push(value);\n    }\n\n    return null;\n  }\n}\n\n/** This is an internal helper function that's just used for testing */\nexport function _decodeChunks(chunks: string[]): string[] {\n  const decoder = new LineDecoder();\n  const lines: string[] = [];\n  for (const chunk of chunks) {\n    lines.push(...decoder.decode(chunk));\n  }\n\n  return lines;\n}\n\nfunction partition(str: string, delimiter: string): [string, string, string] {\n  const index = str.indexOf(delimiter);\n  if (index !== -1) {\n    return [str.substring(0, index), delimiter, str.substring(index + delimiter.length)];\n  }\n\n  return [str, '', ''];\n}\n\n/**\n * Most browsers don't yet have async iterable support for ReadableStream,\n * and Node has a very different way of reading bytes from its \"ReadableStream\".\n *\n * This polyfill was pulled from https://github.com/MattiasBuelens/web-streams-polyfill/pull/122#issuecomment-1627354490\n */\nexport function readableStreamAsyncIterable<T>(stream: any): AsyncIterableIterator<T> {\n  if (stream[Symbol.asyncIterator]) return stream;\n\n  const reader = stream.getReader();\n  return {\n    async next() {\n      try {\n        const result = await reader.read();\n        if (result?.done) reader.releaseLock(); // release lock when stream becomes closed\n        return result;\n      } catch (e) {\n        reader.releaseLock(); // release lock when stream becomes errored\n        throw e;\n      }\n    },\n    async return() {\n      const cancelPromise = reader.cancel();\n      reader.releaseLock();\n      await cancelPromise;\n      return { done: true, value: undefined };\n    },\n    [Symbol.asyncIterator]() {\n      return this;\n    },\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}