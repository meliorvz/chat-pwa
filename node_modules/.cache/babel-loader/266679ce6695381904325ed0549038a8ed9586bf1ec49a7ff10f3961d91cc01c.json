{"ast":null,"code":"import _awaitAsyncGenerator from \"/Users/victor/Documents/Sublime/claude_api_project/chat-pwa/node_modules/@babel/runtime/helpers/esm/awaitAsyncGenerator.js\";\nimport _wrapAsyncGenerator from \"/Users/victor/Documents/Sublime/claude_api_project/chat-pwa/node_modules/@babel/runtime/helpers/esm/wrapAsyncGenerator.js\";\nimport _asyncIterator from \"/Users/victor/Documents/Sublime/claude_api_project/chat-pwa/node_modules/@babel/runtime/helpers/esm/asyncIterator.js\";\nimport { ReadableStream } from \"./_shims/index.mjs\";\nimport { AnthropicError } from \"./error.mjs\";\nimport { safeJSON, createResponseHeaders } from '@anthropic-ai/sdk/core';\nimport { APIError } from '@anthropic-ai/sdk/error';\nexport class Stream {\n  constructor(iterator, controller) {\n    this.iterator = iterator;\n    this.controller = controller;\n  }\n  static fromSSEResponse(response, controller) {\n    let consumed = false;\n    const decoder = new SSEDecoder();\n    function iterMessages() {\n      return _iterMessages.apply(this, arguments);\n    }\n    function _iterMessages() {\n      _iterMessages = _wrapAsyncGenerator(function* () {\n        if (!response.body) {\n          controller.abort();\n          throw new AnthropicError(\"Attempted to iterate over a response with no body\");\n        }\n        const lineDecoder = new LineDecoder();\n        const iter = readableStreamAsyncIterable(response.body);\n        var _iteratorAbruptCompletion = false;\n        var _didIteratorError = false;\n        var _iteratorError;\n        try {\n          for (var _iterator = _asyncIterator(iter), _step; _iteratorAbruptCompletion = !(_step = yield _awaitAsyncGenerator(_iterator.next())).done; _iteratorAbruptCompletion = false) {\n            const chunk = _step.value;\n            {\n              for (const line of lineDecoder.decode(chunk)) {\n                const sse = decoder.decode(line);\n                if (sse) yield sse;\n              }\n            }\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (_iteratorAbruptCompletion && _iterator.return != null) {\n              yield _awaitAsyncGenerator(_iterator.return());\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n        for (const line of lineDecoder.flush()) {\n          const sse = decoder.decode(line);\n          if (sse) yield sse;\n        }\n      });\n      return _iterMessages.apply(this, arguments);\n    }\n    function iterator() {\n      return _iterator3.apply(this, arguments);\n    }\n    function _iterator3() {\n      _iterator3 = _wrapAsyncGenerator(function* () {\n        if (consumed) {\n          throw new Error('Cannot iterate over a consumed stream, use `.tee()` to split the stream.');\n        }\n        consumed = true;\n        let done = false;\n        try {\n          var _iteratorAbruptCompletion2 = false;\n          var _didIteratorError2 = false;\n          var _iteratorError2;\n          try {\n            for (var _iterator2 = _asyncIterator(iterMessages()), _step2; _iteratorAbruptCompletion2 = !(_step2 = yield _awaitAsyncGenerator(_iterator2.next())).done; _iteratorAbruptCompletion2 = false) {\n              const sse = _step2.value;\n              {\n                if (sse.event === 'completion') {\n                  try {\n                    yield JSON.parse(sse.data);\n                  } catch (e) {\n                    console.error(\"Could not parse message into JSON:\", sse.data);\n                    console.error(\"From chunk:\", sse.raw);\n                    throw e;\n                  }\n                }\n                if (sse.event === 'message_start' || sse.event === 'message_delta' || sse.event === 'message_stop' || sse.event === 'content_block_start' || sse.event === 'content_block_delta' || sse.event === 'content_block_stop') {\n                  try {\n                    yield JSON.parse(sse.data);\n                  } catch (e) {\n                    console.error(\"Could not parse message into JSON:\", sse.data);\n                    console.error(\"From chunk:\", sse.raw);\n                    throw e;\n                  }\n                }\n                if (sse.event === 'ping') {\n                  continue;\n                }\n                if (sse.event === 'error') {\n                  const errText = sse.data;\n                  const errJSON = safeJSON(errText);\n                  const errMessage = errJSON ? undefined : errText;\n                  throw APIError.generate(undefined, errJSON, errMessage, createResponseHeaders(response.headers));\n                }\n              }\n            }\n          } catch (err) {\n            _didIteratorError2 = true;\n            _iteratorError2 = err;\n          } finally {\n            try {\n              if (_iteratorAbruptCompletion2 && _iterator2.return != null) {\n                yield _awaitAsyncGenerator(_iterator2.return());\n              }\n            } finally {\n              if (_didIteratorError2) {\n                throw _iteratorError2;\n              }\n            }\n          }\n          done = true;\n        } catch (e) {\n          // If the user calls `stream.controller.abort()`, we should exit without throwing.\n          if (e instanceof Error && e.name === 'AbortError') return;\n          throw e;\n        } finally {\n          // If the user `break`s, abort the ongoing request.\n          if (!done) controller.abort();\n        }\n      });\n      return _iterator3.apply(this, arguments);\n    }\n    return new Stream(iterator, controller);\n  }\n  /**\n   * Generates a Stream from a newline-separated ReadableStream\n   * where each item is a JSON value.\n   */\n  static fromReadableStream(readableStream, controller) {\n    let consumed = false;\n    function iterLines() {\n      return _iterLines.apply(this, arguments);\n    }\n    function _iterLines() {\n      _iterLines = _wrapAsyncGenerator(function* () {\n        const lineDecoder = new LineDecoder();\n        const iter = readableStreamAsyncIterable(readableStream);\n        var _iteratorAbruptCompletion3 = false;\n        var _didIteratorError3 = false;\n        var _iteratorError3;\n        try {\n          for (var _iterator4 = _asyncIterator(iter), _step3; _iteratorAbruptCompletion3 = !(_step3 = yield _awaitAsyncGenerator(_iterator4.next())).done; _iteratorAbruptCompletion3 = false) {\n            const chunk = _step3.value;\n            {\n              for (const line of lineDecoder.decode(chunk)) {\n                yield line;\n              }\n            }\n          }\n        } catch (err) {\n          _didIteratorError3 = true;\n          _iteratorError3 = err;\n        } finally {\n          try {\n            if (_iteratorAbruptCompletion3 && _iterator4.return != null) {\n              yield _awaitAsyncGenerator(_iterator4.return());\n            }\n          } finally {\n            if (_didIteratorError3) {\n              throw _iteratorError3;\n            }\n          }\n        }\n        for (const line of lineDecoder.flush()) {\n          yield line;\n        }\n      });\n      return _iterLines.apply(this, arguments);\n    }\n    function iterator() {\n      return _iterator6.apply(this, arguments);\n    }\n    function _iterator6() {\n      _iterator6 = _wrapAsyncGenerator(function* () {\n        if (consumed) {\n          throw new Error('Cannot iterate over a consumed stream, use `.tee()` to split the stream.');\n        }\n        consumed = true;\n        let done = false;\n        try {\n          var _iteratorAbruptCompletion4 = false;\n          var _didIteratorError4 = false;\n          var _iteratorError4;\n          try {\n            for (var _iterator5 = _asyncIterator(iterLines()), _step4; _iteratorAbruptCompletion4 = !(_step4 = yield _awaitAsyncGenerator(_iterator5.next())).done; _iteratorAbruptCompletion4 = false) {\n              const line = _step4.value;\n              {\n                if (done) continue;\n                if (line) yield JSON.parse(line);\n              }\n            }\n          } catch (err) {\n            _didIteratorError4 = true;\n            _iteratorError4 = err;\n          } finally {\n            try {\n              if (_iteratorAbruptCompletion4 && _iterator5.return != null) {\n                yield _awaitAsyncGenerator(_iterator5.return());\n              }\n            } finally {\n              if (_didIteratorError4) {\n                throw _iteratorError4;\n              }\n            }\n          }\n          done = true;\n        } catch (e) {\n          // If the user calls `stream.controller.abort()`, we should exit without throwing.\n          if (e instanceof Error && e.name === 'AbortError') return;\n          throw e;\n        } finally {\n          // If the user `break`s, abort the ongoing request.\n          if (!done) controller.abort();\n        }\n      });\n      return _iterator6.apply(this, arguments);\n    }\n    return new Stream(iterator, controller);\n  }\n  [Symbol.asyncIterator]() {\n    return this.iterator();\n  }\n  /**\n   * Splits the stream into two streams which can be\n   * independently read from at different speeds.\n   */\n  tee() {\n    const left = [];\n    const right = [];\n    const iterator = this.iterator();\n    const teeIterator = queue => {\n      return {\n        next: () => {\n          if (queue.length === 0) {\n            const result = iterator.next();\n            left.push(result);\n            right.push(result);\n          }\n          return queue.shift();\n        }\n      };\n    };\n    return [new Stream(() => teeIterator(left), this.controller), new Stream(() => teeIterator(right), this.controller)];\n  }\n  /**\n   * Converts this stream to a newline-separated ReadableStream of\n   * JSON stringified values in the stream\n   * which can be turned back into a Stream with `Stream.fromReadableStream()`.\n   */\n  toReadableStream() {\n    const self = this;\n    let iter;\n    const encoder = new TextEncoder();\n    return new ReadableStream({\n      async start() {\n        iter = self[Symbol.asyncIterator]();\n      },\n      async pull(ctrl) {\n        try {\n          const {\n            value,\n            done\n          } = await iter.next();\n          if (done) return ctrl.close();\n          const bytes = encoder.encode(JSON.stringify(value) + '\\n');\n          ctrl.enqueue(bytes);\n        } catch (err) {\n          ctrl.error(err);\n        }\n      },\n      async cancel() {\n        var _iter$return, _iter;\n        await ((_iter$return = (_iter = iter).return) === null || _iter$return === void 0 ? void 0 : _iter$return.call(_iter));\n      }\n    });\n  }\n}\nclass SSEDecoder {\n  constructor() {\n    this.event = null;\n    this.data = [];\n    this.chunks = [];\n  }\n  decode(line) {\n    if (line.endsWith('\\r')) {\n      line = line.substring(0, line.length - 1);\n    }\n    if (!line) {\n      // empty line and we didn't previously encounter any messages\n      if (!this.event && !this.data.length) return null;\n      const sse = {\n        event: this.event,\n        data: this.data.join('\\n'),\n        raw: this.chunks\n      };\n      this.event = null;\n      this.data = [];\n      this.chunks = [];\n      return sse;\n    }\n    this.chunks.push(line);\n    if (line.startsWith(':')) {\n      return null;\n    }\n    let [fieldname, _, value] = partition(line, ':');\n    if (value.startsWith(' ')) {\n      value = value.substring(1);\n    }\n    if (fieldname === 'event') {\n      this.event = value;\n    } else if (fieldname === 'data') {\n      this.data.push(value);\n    }\n    return null;\n  }\n}\n/**\n * A re-implementation of httpx's `LineDecoder` in Python that handles incrementally\n * reading lines from text.\n *\n * https://github.com/encode/httpx/blob/920333ea98118e9cf617f246905d7b202510941c/httpx/_decoders.py#L258\n */\nclass LineDecoder {\n  constructor() {\n    this.buffer = [];\n    this.trailingCR = false;\n  }\n  decode(chunk) {\n    let text = this.decodeText(chunk);\n    if (this.trailingCR) {\n      text = '\\r' + text;\n      this.trailingCR = false;\n    }\n    if (text.endsWith('\\r')) {\n      this.trailingCR = true;\n      text = text.slice(0, -1);\n    }\n    if (!text) {\n      return [];\n    }\n    const trailingNewline = LineDecoder.NEWLINE_CHARS.has(text[text.length - 1] || '');\n    let lines = text.split(LineDecoder.NEWLINE_REGEXP);\n    // if there is a trailing new line then the last entry will be an empty\n    // string which we don't care about\n    if (trailingNewline) {\n      lines.pop();\n    }\n    if (lines.length === 1 && !trailingNewline) {\n      this.buffer.push(lines[0]);\n      return [];\n    }\n    if (this.buffer.length > 0) {\n      lines = [this.buffer.join('') + lines[0], ...lines.slice(1)];\n      this.buffer = [];\n    }\n    if (!trailingNewline) {\n      this.buffer = [lines.pop() || ''];\n    }\n    return lines;\n  }\n  decodeText(bytes) {\n    if (bytes == null) return '';\n    if (typeof bytes === 'string') return bytes;\n    // Node:\n    if (typeof Buffer !== 'undefined') {\n      if (bytes instanceof Buffer) {\n        return bytes.toString();\n      }\n      if (bytes instanceof Uint8Array) {\n        return Buffer.from(bytes).toString();\n      }\n      throw new AnthropicError(\"Unexpected: received non-Uint8Array (\".concat(bytes.constructor.name, \") stream chunk in an environment with a global \\\"Buffer\\\" defined, which this library assumes to be Node. Please report this error.\"));\n    }\n    // Browser\n    if (typeof TextDecoder !== 'undefined') {\n      if (bytes instanceof Uint8Array || bytes instanceof ArrayBuffer) {\n        var _this$textDecoder;\n        (_this$textDecoder = this.textDecoder) !== null && _this$textDecoder !== void 0 ? _this$textDecoder : this.textDecoder = new TextDecoder('utf8');\n        return this.textDecoder.decode(bytes);\n      }\n      throw new AnthropicError(\"Unexpected: received non-Uint8Array/ArrayBuffer (\".concat(bytes.constructor.name, \") in a web platform. Please report this error.\"));\n    }\n    throw new AnthropicError(\"Unexpected: neither Buffer nor TextDecoder are available as globals. Please report this error.\");\n  }\n  flush() {\n    if (!this.buffer.length && !this.trailingCR) {\n      return [];\n    }\n    const lines = [this.buffer.join('')];\n    this.buffer = [];\n    this.trailingCR = false;\n    return lines;\n  }\n}\n// prettier-ignore\nLineDecoder.NEWLINE_CHARS = new Set(['\\n', '\\r', '\\x0b', '\\x0c', '\\x1c', '\\x1d', '\\x1e', '\\x85', '\\u2028', '\\u2029']);\nLineDecoder.NEWLINE_REGEXP = /\\r\\n|[\\n\\r\\x0b\\x0c\\x1c\\x1d\\x1e\\x85\\u2028\\u2029]/g;\n/** This is an internal helper function that's just used for testing */\nexport function _decodeChunks(chunks) {\n  const decoder = new LineDecoder();\n  const lines = [];\n  for (const chunk of chunks) {\n    lines.push(...decoder.decode(chunk));\n  }\n  return lines;\n}\nfunction partition(str, delimiter) {\n  const index = str.indexOf(delimiter);\n  if (index !== -1) {\n    return [str.substring(0, index), delimiter, str.substring(index + delimiter.length)];\n  }\n  return [str, '', ''];\n}\n/**\n * Most browsers don't yet have async iterable support for ReadableStream,\n * and Node has a very different way of reading bytes from its \"ReadableStream\".\n *\n * This polyfill was pulled from https://github.com/MattiasBuelens/web-streams-polyfill/pull/122#issuecomment-1627354490\n */\nexport function readableStreamAsyncIterable(stream) {\n  if (stream[Symbol.asyncIterator]) return stream;\n  const reader = stream.getReader();\n  return {\n    async next() {\n      try {\n        const result = await reader.read();\n        if (result !== null && result !== void 0 && result.done) reader.releaseLock(); // release lock when stream becomes closed\n        return result;\n      } catch (e) {\n        reader.releaseLock(); // release lock when stream becomes errored\n        throw e;\n      }\n    },\n    async return() {\n      const cancelPromise = reader.cancel();\n      reader.releaseLock();\n      await cancelPromise;\n      return {\n        done: true,\n        value: undefined\n      };\n    },\n    [Symbol.asyncIterator]() {\n      return this;\n    }\n  };\n}","map":{"version":3,"names":["ReadableStream","AnthropicError","safeJSON","createResponseHeaders","APIError","Stream","constructor","iterator","controller","fromSSEResponse","response","consumed","decoder","SSEDecoder","iterMessages","_iterMessages","apply","arguments","_wrapAsyncGenerator","body","abort","lineDecoder","LineDecoder","iter","readableStreamAsyncIterable","_iteratorAbruptCompletion","_didIteratorError","_iteratorError","_iterator","_asyncIterator","_step","_awaitAsyncGenerator","next","done","chunk","value","line","decode","sse","err","return","flush","_iterator3","Error","_iteratorAbruptCompletion2","_didIteratorError2","_iteratorError2","_iterator2","_step2","event","JSON","parse","data","e","console","error","raw","errText","errJSON","errMessage","undefined","generate","headers","name","fromReadableStream","readableStream","iterLines","_iterLines","_iteratorAbruptCompletion3","_didIteratorError3","_iteratorError3","_iterator4","_step3","_iterator6","_iteratorAbruptCompletion4","_didIteratorError4","_iteratorError4","_iterator5","_step4","Symbol","asyncIterator","tee","left","right","teeIterator","queue","length","result","push","shift","toReadableStream","self","encoder","TextEncoder","start","pull","ctrl","close","bytes","encode","stringify","enqueue","cancel","_iter$return","_iter","call","chunks","endsWith","substring","join","startsWith","fieldname","_","partition","buffer","trailingCR","text","decodeText","slice","trailingNewline","NEWLINE_CHARS","has","lines","split","NEWLINE_REGEXP","pop","Buffer","toString","Uint8Array","from","concat","TextDecoder","ArrayBuffer","_this$textDecoder","textDecoder","Set","_decodeChunks","str","delimiter","index","indexOf","stream","reader","getReader","read","releaseLock","cancelPromise"],"sources":["/Users/victor/Documents/Sublime/claude_api_project/chat-pwa/node_modules/@anthropic-ai/sdk/src/streaming.ts"],"sourcesContent":["import { ReadableStream, type Response } from './_shims/index';\nimport { AnthropicError } from './error';\n\nimport { safeJSON, createResponseHeaders } from \"./core\";\nimport { APIError } from \"./error\";\n\ntype Bytes = string | ArrayBuffer | Uint8Array | Buffer | null | undefined;\n\nexport type ServerSentEvent = {\n  event: string | null;\n  data: string;\n  raw: string[];\n};\n\nexport class Stream<Item> implements AsyncIterable<Item> {\n  controller: AbortController;\n\n  constructor(\n    private iterator: () => AsyncIterator<Item>,\n    controller: AbortController,\n  ) {\n    this.controller = controller;\n  }\n\n  static fromSSEResponse<Item>(response: Response, controller: AbortController) {\n    let consumed = false;\n    const decoder = new SSEDecoder();\n\n    async function* iterMessages(): AsyncGenerator<ServerSentEvent, void, unknown> {\n      if (!response.body) {\n        controller.abort();\n        throw new AnthropicError(`Attempted to iterate over a response with no body`);\n      }\n\n      const lineDecoder = new LineDecoder();\n\n      const iter = readableStreamAsyncIterable<Bytes>(response.body);\n      for await (const chunk of iter) {\n        for (const line of lineDecoder.decode(chunk)) {\n          const sse = decoder.decode(line);\n          if (sse) yield sse;\n        }\n      }\n\n      for (const line of lineDecoder.flush()) {\n        const sse = decoder.decode(line);\n        if (sse) yield sse;\n      }\n    }\n\n    async function* iterator(): AsyncIterator<Item, any, undefined> {\n      if (consumed) {\n        throw new Error('Cannot iterate over a consumed stream, use `.tee()` to split the stream.');\n      }\n      consumed = true;\n      let done = false;\n      try {\n        for await (const sse of iterMessages()) {\n          if (sse.event === 'completion') {\n            try {\n              yield JSON.parse(sse.data);\n            } catch (e) {\n              console.error(`Could not parse message into JSON:`, sse.data);\n              console.error(`From chunk:`, sse.raw);\n              throw e;\n            }\n          }\n\n          if (\n            sse.event === 'message_start' ||\n            sse.event === 'message_delta' ||\n            sse.event === 'message_stop' ||\n            sse.event === 'content_block_start' ||\n            sse.event === 'content_block_delta' ||\n            sse.event === 'content_block_stop'\n          ) {\n            try {\n              yield JSON.parse(sse.data);\n            } catch (e) {\n              console.error(`Could not parse message into JSON:`, sse.data);\n              console.error(`From chunk:`, sse.raw);\n              throw e;\n            }\n          }\n\n          if (sse.event === 'ping') {\n            continue;\n          }\n\n          if (sse.event === 'error') {\n            const errText = sse.data;\n            const errJSON = safeJSON(errText);\n            const errMessage = errJSON ? undefined : errText;\n\n            throw APIError.generate(undefined, errJSON, errMessage, createResponseHeaders(response.headers));\n          }\n        }\n        done = true;\n      } catch (e) {\n        // If the user calls `stream.controller.abort()`, we should exit without throwing.\n        if (e instanceof Error && e.name === 'AbortError') return;\n        throw e;\n      } finally {\n        // If the user `break`s, abort the ongoing request.\n        if (!done) controller.abort();\n      }\n    }\n\n    return new Stream(iterator, controller);\n  }\n\n  /**\n   * Generates a Stream from a newline-separated ReadableStream\n   * where each item is a JSON value.\n   */\n  static fromReadableStream<Item>(readableStream: ReadableStream, controller: AbortController) {\n    let consumed = false;\n\n    async function* iterLines(): AsyncGenerator<string, void, unknown> {\n      const lineDecoder = new LineDecoder();\n\n      const iter = readableStreamAsyncIterable<Bytes>(readableStream);\n      for await (const chunk of iter) {\n        for (const line of lineDecoder.decode(chunk)) {\n          yield line;\n        }\n      }\n\n      for (const line of lineDecoder.flush()) {\n        yield line;\n      }\n    }\n\n    async function* iterator(): AsyncIterator<Item, any, undefined> {\n      if (consumed) {\n        throw new Error('Cannot iterate over a consumed stream, use `.tee()` to split the stream.');\n      }\n      consumed = true;\n      let done = false;\n      try {\n        for await (const line of iterLines()) {\n          if (done) continue;\n          if (line) yield JSON.parse(line);\n        }\n        done = true;\n      } catch (e) {\n        // If the user calls `stream.controller.abort()`, we should exit without throwing.\n        if (e instanceof Error && e.name === 'AbortError') return;\n        throw e;\n      } finally {\n        // If the user `break`s, abort the ongoing request.\n        if (!done) controller.abort();\n      }\n    }\n\n    return new Stream(iterator, controller);\n  }\n\n  [Symbol.asyncIterator](): AsyncIterator<Item> {\n    return this.iterator();\n  }\n\n  /**\n   * Splits the stream into two streams which can be\n   * independently read from at different speeds.\n   */\n  tee(): [Stream<Item>, Stream<Item>] {\n    const left: Array<Promise<IteratorResult<Item>>> = [];\n    const right: Array<Promise<IteratorResult<Item>>> = [];\n    const iterator = this.iterator();\n\n    const teeIterator = (queue: Array<Promise<IteratorResult<Item>>>): AsyncIterator<Item> => {\n      return {\n        next: () => {\n          if (queue.length === 0) {\n            const result = iterator.next();\n            left.push(result);\n            right.push(result);\n          }\n          return queue.shift()!;\n        },\n      };\n    };\n\n    return [\n      new Stream(() => teeIterator(left), this.controller),\n      new Stream(() => teeIterator(right), this.controller),\n    ];\n  }\n\n  /**\n   * Converts this stream to a newline-separated ReadableStream of\n   * JSON stringified values in the stream\n   * which can be turned back into a Stream with `Stream.fromReadableStream()`.\n   */\n  toReadableStream(): ReadableStream {\n    const self = this;\n    let iter: AsyncIterator<Item>;\n    const encoder = new TextEncoder();\n\n    return new ReadableStream({\n      async start() {\n        iter = self[Symbol.asyncIterator]();\n      },\n      async pull(ctrl) {\n        try {\n          const { value, done } = await iter.next();\n          if (done) return ctrl.close();\n\n          const bytes = encoder.encode(JSON.stringify(value) + '\\n');\n\n          ctrl.enqueue(bytes);\n        } catch (err) {\n          ctrl.error(err);\n        }\n      },\n      async cancel() {\n        await iter.return?.();\n      },\n    });\n  }\n}\n\nclass SSEDecoder {\n  private data: string[];\n  private event: string | null;\n  private chunks: string[];\n\n  constructor() {\n    this.event = null;\n    this.data = [];\n    this.chunks = [];\n  }\n\n  decode(line: string) {\n    if (line.endsWith('\\r')) {\n      line = line.substring(0, line.length - 1);\n    }\n\n    if (!line) {\n      // empty line and we didn't previously encounter any messages\n      if (!this.event && !this.data.length) return null;\n\n      const sse: ServerSentEvent = {\n        event: this.event,\n        data: this.data.join('\\n'),\n        raw: this.chunks,\n      };\n\n      this.event = null;\n      this.data = [];\n      this.chunks = [];\n\n      return sse;\n    }\n\n    this.chunks.push(line);\n\n    if (line.startsWith(':')) {\n      return null;\n    }\n\n    let [fieldname, _, value] = partition(line, ':');\n\n    if (value.startsWith(' ')) {\n      value = value.substring(1);\n    }\n\n    if (fieldname === 'event') {\n      this.event = value;\n    } else if (fieldname === 'data') {\n      this.data.push(value);\n    }\n\n    return null;\n  }\n}\n\n/**\n * A re-implementation of httpx's `LineDecoder` in Python that handles incrementally\n * reading lines from text.\n *\n * https://github.com/encode/httpx/blob/920333ea98118e9cf617f246905d7b202510941c/httpx/_decoders.py#L258\n */\nclass LineDecoder {\n  // prettier-ignore\n  static NEWLINE_CHARS = new Set(['\\n', '\\r', '\\x0b', '\\x0c', '\\x1c', '\\x1d', '\\x1e', '\\x85', '\\u2028', '\\u2029']);\n  static NEWLINE_REGEXP = /\\r\\n|[\\n\\r\\x0b\\x0c\\x1c\\x1d\\x1e\\x85\\u2028\\u2029]/g;\n\n  buffer: string[];\n  trailingCR: boolean;\n  textDecoder: any; // TextDecoder found in browsers; not typed to avoid pulling in either \"dom\" or \"node\" types.\n\n  constructor() {\n    this.buffer = [];\n    this.trailingCR = false;\n  }\n\n  decode(chunk: Bytes): string[] {\n    let text = this.decodeText(chunk);\n\n    if (this.trailingCR) {\n      text = '\\r' + text;\n      this.trailingCR = false;\n    }\n    if (text.endsWith('\\r')) {\n      this.trailingCR = true;\n      text = text.slice(0, -1);\n    }\n\n    if (!text) {\n      return [];\n    }\n\n    const trailingNewline = LineDecoder.NEWLINE_CHARS.has(text[text.length - 1] || '');\n    let lines = text.split(LineDecoder.NEWLINE_REGEXP);\n\n    // if there is a trailing new line then the last entry will be an empty\n    // string which we don't care about\n    if (trailingNewline) {\n      lines.pop();\n    }\n\n    if (lines.length === 1 && !trailingNewline) {\n      this.buffer.push(lines[0]!);\n      return [];\n    }\n\n    if (this.buffer.length > 0) {\n      lines = [this.buffer.join('') + lines[0], ...lines.slice(1)];\n      this.buffer = [];\n    }\n\n    if (!trailingNewline) {\n      this.buffer = [lines.pop() || ''];\n    }\n\n    return lines;\n  }\n\n  decodeText(bytes: Bytes): string {\n    if (bytes == null) return '';\n    if (typeof bytes === 'string') return bytes;\n\n    // Node:\n    if (typeof Buffer !== 'undefined') {\n      if (bytes instanceof Buffer) {\n        return bytes.toString();\n      }\n      if (bytes instanceof Uint8Array) {\n        return Buffer.from(bytes).toString();\n      }\n\n      throw new AnthropicError(\n        `Unexpected: received non-Uint8Array (${bytes.constructor.name}) stream chunk in an environment with a global \"Buffer\" defined, which this library assumes to be Node. Please report this error.`,\n      );\n    }\n\n    // Browser\n    if (typeof TextDecoder !== 'undefined') {\n      if (bytes instanceof Uint8Array || bytes instanceof ArrayBuffer) {\n        this.textDecoder ??= new TextDecoder('utf8');\n        return this.textDecoder.decode(bytes);\n      }\n\n      throw new AnthropicError(\n        `Unexpected: received non-Uint8Array/ArrayBuffer (${\n          (bytes as any).constructor.name\n        }) in a web platform. Please report this error.`,\n      );\n    }\n\n    throw new AnthropicError(\n      `Unexpected: neither Buffer nor TextDecoder are available as globals. Please report this error.`,\n    );\n  }\n\n  flush(): string[] {\n    if (!this.buffer.length && !this.trailingCR) {\n      return [];\n    }\n\n    const lines = [this.buffer.join('')];\n    this.buffer = [];\n    this.trailingCR = false;\n    return lines;\n  }\n}\n\n/** This is an internal helper function that's just used for testing */\nexport function _decodeChunks(chunks: string[]): string[] {\n  const decoder = new LineDecoder();\n  const lines: string[] = [];\n  for (const chunk of chunks) {\n    lines.push(...decoder.decode(chunk));\n  }\n\n  return lines;\n}\n\nfunction partition(str: string, delimiter: string): [string, string, string] {\n  const index = str.indexOf(delimiter);\n  if (index !== -1) {\n    return [str.substring(0, index), delimiter, str.substring(index + delimiter.length)];\n  }\n\n  return [str, '', ''];\n}\n\n/**\n * Most browsers don't yet have async iterable support for ReadableStream,\n * and Node has a very different way of reading bytes from its \"ReadableStream\".\n *\n * This polyfill was pulled from https://github.com/MattiasBuelens/web-streams-polyfill/pull/122#issuecomment-1627354490\n */\nexport function readableStreamAsyncIterable<T>(stream: any): AsyncIterableIterator<T> {\n  if (stream[Symbol.asyncIterator]) return stream;\n\n  const reader = stream.getReader();\n  return {\n    async next() {\n      try {\n        const result = await reader.read();\n        if (result?.done) reader.releaseLock(); // release lock when stream becomes closed\n        return result;\n      } catch (e) {\n        reader.releaseLock(); // release lock when stream becomes errored\n        throw e;\n      }\n    },\n    async return() {\n      const cancelPromise = reader.cancel();\n      reader.releaseLock();\n      await cancelPromise;\n      return { done: true, value: undefined };\n    },\n    [Symbol.asyncIterator]() {\n      return this;\n    },\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}